

==================== FILE: ./requirements.txt ====================

aiofiles==23.2.1
aiogram==3.6.0
aiohttp==3.9.5
aiosignal==1.4.0
aiosqlite==0.20.0
annotated-types==0.7.0
APScheduler==3.11.2
attrs==25.4.0
certifi==2026.1.4
frozenlist==1.8.0
idna==3.11
magic-filter==1.0.12
multidict==6.7.0
propcache==0.4.1
pydantic==2.7.4
pydantic_core==2.18.4
python-dotenv==1.0.1
pytz==2024.1
typing_extensions==4.15.0
tzlocal==5.3.1
yarl==1.22.0


==================== FILE: ./code_context.txt ====================



==================== FILE: ./README.md ====================

‚òï SaaS Coffee Shop Bot
–ú–Ω–æ–≥–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–µ—Ç—å—é –∫–æ—Ñ–µ–µ–Ω –≤ Telegram.

–ë–æ—Ç —Ä–∞–±–æ—Ç–∞–µ—Ç –ø–æ –º–æ–¥–µ–ª–∏ SaaS (Software as a Service): –æ–¥–∏–Ω —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞ –æ–±—Å–ª—É–∂–∏–≤–∞–µ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∫–æ—Ñ–µ–µ–Ω –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ. –í–ª–∞–¥–µ–ª—å—Ü—ã –∑–∞–≤–µ–¥–µ–Ω–∏–π –ø–æ–ª—É—á–∞—é—Ç —É–¥–æ–±–Ω—É—é –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å, –∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∏ ‚Äî –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å–æ —Å–º–µ–Ω–∞–º–∏ –∏ –∑–∞–¥–∞—á–∞–º–∏.

‚ú® –û—Å–Ω–æ–≤–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏

üëë Super Admin (–í–ª–∞–¥–µ–ª–µ—Ü –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã)

–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–∏—Ü–µ–Ω–∑–∏–π (Magic Links): –°–æ–∑–¥–∞–Ω–∏–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –Ω–æ–≤—ã—Ö –∑–∞–≤–µ–¥–µ–Ω–∏–π.

–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ—Ñ–µ–π–Ω—è–º–∏: –ü—Ä–æ—Å–º–æ—Ç—Ä —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ—Ñ–µ–µ–Ω, –∏—Ö —Å—Ç–∞—Ç—É—Å–∞ –∏ –≤–ª–∞–¥–µ–ª—å—Ü–µ–≤.

–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–æ—Å—Ç—É–ø–∞: –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å "–∑–∞–º–æ—Ä–æ–∑–∏—Ç—å" (–æ—Ç–∫–ª—é—á–∏—Ç—å) –¥–æ—Å—Ç—É–ø –∫ –±–æ—Ç—É –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–æ—Ñ–µ–π–Ω–∏ –∑–∞ –Ω–µ—É–ø–ª–∞—Ç—É –∏–ª–∏ –Ω–∞—Ä—É—à–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª.

–ì–ª–æ–±–∞–ª—å–Ω–∞—è —Ä–∞—Å—Å—ã–ª–∫–∞: –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –≤—Å–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞–º –∫–æ—Ñ–µ–µ–Ω.

üè¢ Admin (–í–ª–∞–¥–µ–ª–µ—Ü –∫–æ—Ñ–µ–π–Ω–∏)
–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–ª–æ–º:
–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–≥–ª–∞—Å–∏—Ç–µ–ª—å–Ω—ã—Ö —Å—Å—ã–ª–æ–∫ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ä–æ–ª–µ–π (–ë–∞—Ä–∏—Å—Ç–∞, –ú–µ–Ω–µ–¥–∂–µ—Ä –∏ —Ç.–¥.).
–ü—Ä–æ—Å–º–æ—Ç—Ä —Å–ø–∏—Å–∫–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –∏ –∏—Ö –±–∞–ª–∞–Ω—Å–∞.
–£–≤–æ–ª—å–Ω–µ–Ω–∏–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–æ–ª–µ–π.

–ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –ß–µ–∫-–ª–∏—Å—Ç–æ–≤:
–°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–¥–∞—á –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Å–º–µ–Ω (–£—Ç—Ä–æ, –î–µ–Ω—å, –í–µ—á–µ—Ä).
–ü—Ä–∏–≤—è–∑–∫–∞ –∑–∞–¥–∞—á –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º —Ä–æ–ª—è–º.

–§–∏–Ω–∞–Ω—Å—ã –∏ KPI:
–ù–∞—á–∏—Å–ª–µ–Ω–∏–µ –ø—Ä–µ–º–∏–π –∏ —à—Ç—Ä–∞—Ñ–æ–≤ (–≤–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è –≤–∞–ª—é—Ç–∞/–±–∞–ª–ª—ã).
–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–∞—Å—á–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ (KPI) –Ω–∞ –æ—Å–Ω–æ–≤–µ –∑–∞–∫—Ä—ã—Ç—ã—Ö —Å–º–µ–Ω.

–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥:
–ü—Ä–æ—Å–º–æ—Ç—Ä –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–º–µ–Ω –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏.
–ü–æ–ª—É—á–µ–Ω–∏–µ –≤–∏–¥–µ–æ-–æ—Ç—á–µ—Ç–æ–≤ (–∫—Ä—É–∂–æ—á–∫–æ–≤) –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ —Å–º–µ–Ω—ã.

–ó–∞–¥–∞—á–∏:
–ü–æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–∞–∑–æ–≤—ã—Ö –∑–∞–¥–∞—á —Å –¥–µ–¥–ª–∞–π–Ω–∞–º–∏ –∏ –Ω–∞–≥—Ä–∞–¥–∞–º–∏.
–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á–∞—Ö.

‚òï –°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏
–°–º–µ–Ω—ã: –û—Ç–∫—Ä—ã—Ç–∏–µ –∏ –∑–∞–∫—Ä—ã—Ç–∏–µ —Å–º–µ–Ω—ã —Å –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º –≤–∏–¥–µ–æ-–ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ–º (Video Note).
–ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ —á–µ–∫-–ª–∏—Å—Ç—ã: –û—Ç–º–µ—Ç–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –¥–µ–ª –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏.
–õ–∏—á–Ω—ã–π –∫–∞–±–∏–Ω–µ—Ç: –ü—Ä–æ—Å–º–æ—Ç—Ä –∏—Å—Ç–æ—Ä–∏–∏ —Å–º–µ–Ω –∏ –±–∞–ª–∞–Ω—Å–∞ –∑–∞—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –±–∞–ª–ª–æ–≤.
–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è: –ë—ã—Å—Ç—Ä—ã–π –≤—Ö–æ–¥ –ø–æ PIN-–∫–æ–¥—É.

üõ† –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π —Å—Ç–µ–∫
–Ø–∑—ã–∫: Python 3.10+
–§—Ä–µ–π–º–≤–æ—Ä–∫: aiogram 3.x (–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π)
–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö: SQLite (—á–µ—Ä–µ–∑ aiosqlite)
–ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫: APScheduler (–¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–µ–¥–ª–∞–π–Ω–æ–≤)
–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è: python-dotenv
üöÄ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ –∑–∞–ø—É—Å–∫

1. –ö–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏—è
code
Bash
git clone https://github.com/your-username/coffee-shop-bot.git
cd coffee-shop-bot

2. –°–æ–∑–¥–∞–Ω–∏–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è
Linux/macOS:

code
Bash
python3 -m venv .venv
source .venv/bin/activate
Windows:

code
Bash
python -m venv .venv
.venv\Scripts\activate

3. –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
code
Bash
pip install -r requirements.txt

4. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
–ü–µ—Ä–µ–∏–º–µ–Ω—É–π—Ç–µ —Ñ–∞–π–ª .env.example (–µ—Å–ª–∏ –µ—Å—Ç—å) –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π —Ñ–∞–π–ª .env –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞:

code
Ini
# –¢–æ–∫–µ–Ω –≤–∞—à–µ–≥–æ –±–æ—Ç–∞ –æ—Ç @BotFather
BOT_TOKEN=123456789:AAH...

# –í–∞—à —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å (–¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã —Å–º–µ–Ω –∏ —à–µ–¥—É–ª–µ—Ä–∞)
TZ=Asia/Almaty

# –ü–∞—Ä–æ–ª—å –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–∞–Ω–µ–ª–∏ –°—É–ø–µ—Ä-–ê–¥–º–∏–Ω–∞ (–∫–æ–º–∞–Ω–¥–∞ /root_login)
SUPER_ADMIN_PASSWORD=SecretPassword2026

5. –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
code
Bash
python -m app.main

==================== FILE: ./app/__init__.py ====================



==================== FILE: ./app/main.py ====================

import asyncio
import logging
from aiogram import Bot, Dispatcher
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode
from aiogram.client.session.aiohttp import AiohttpSession
from apscheduler.schedulers.asyncio import AsyncIOScheduler

from app.core.config import BOT_TOKEN
from app.database.core import init_db
from app.middlewares.saas import SaasMiddleware

from app.handlers.super_admin import menu as super_admin_menu
from app.handlers import registration, auth, shifts, admin
from app.core.scheduler import send_hourly_reminders, clean_expired_tasks

logging.basicConfig(level=logging.INFO)

async def main():
    await init_db()
    
    session = AiohttpSession(proxy=None)
    bot = Bot(
        token=BOT_TOKEN, 
        session=session,
        default=DefaultBotProperties(parse_mode=ParseMode.HTML)
    )
    
    dp = Dispatcher()
    
    dp.message.outer_middleware(SaasMiddleware())
    dp.callback_query.outer_middleware(SaasMiddleware())

    dp.include_routers(
        super_admin_menu.router,
        registration.router,     
        auth.router,            
        shifts.router, 
        admin.router 
    )

    scheduler = AsyncIOScheduler()
    scheduler.add_job(send_hourly_reminders, 'interval', minutes=1, kwargs={'bot': bot})
    scheduler.add_job(clean_expired_tasks, 'interval', minutes=1, kwargs={'bot': bot})
    scheduler.start()

    print("‚úÖ SaaS –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω!")
    await dp.start_polling(bot, polling_timeout=60, allowed_updates=[])

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        print("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

==================== FILE: ./app/database/__init__.py ====================



==================== FILE: ./app/database/core.py ====================

import aiosqlite
from app.core.config import DB_PATH

async def init_db():
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("PRAGMA journal_mode=WAL;") 
        await db.execute("PRAGMA foreign_keys = ON")
        
        await db.execute("""
            CREATE TABLE IF NOT EXISTS license_keys (
                key_code TEXT PRIMARY KEY,
                is_used BOOLEAN DEFAULT 0,
                target_username TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                activated_by_tg_id INTEGER,
                activated_at TIMESTAMP
            )
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS restaurants (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                owner_tg_id INTEGER NOT NULL,
                is_active BOOLEAN DEFAULT 1, 
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS roles (
                slug TEXT,
                restaurant_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                PRIMARY KEY (slug, restaurant_id),
                FOREIGN KEY (restaurant_id) REFERENCES restaurants(id) ON DELETE CASCADE
            )
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS users (
                tg_id INTEGER,
                restaurant_id INTEGER NOT NULL,
                full_name TEXT NOT NULL,
                role TEXT NOT NULL,
                pin_hash TEXT NOT NULL,
                balance INTEGER DEFAULT 0,
                is_active BOOLEAN DEFAULT 1,
                kpi_reset_at TIMESTAMP,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (tg_id, restaurant_id),
                FOREIGN KEY (restaurant_id) REFERENCES restaurants(id) ON DELETE CASCADE
            )
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS sessions (
                user_id INTEGER PRIMARY KEY,
                active_restaurant_id INTEGER,
                role TEXT,
                FOREIGN KEY (active_restaurant_id) REFERENCES restaurants(id) ON DELETE SET NULL
            )
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS shifts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                restaurant_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                role TEXT NOT NULL,
                shift_type TEXT,
                started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                ended_at TIMESTAMP,
                report TEXT, 
                FOREIGN KEY (restaurant_id) REFERENCES restaurants(id) ON DELETE CASCADE,
                FOREIGN KEY (user_id, restaurant_id) REFERENCES users(tg_id, restaurant_id) ON DELETE RESTRICT
            )
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS extra_tasks (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                restaurant_id INTEGER NOT NULL,
                text TEXT NOT NULL,
                reward INTEGER NOT NULL,
                status TEXT DEFAULT 'pending',
                deadline TIMESTAMP,
                assigned_to INTEGER,
                message_id INTEGER,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (restaurant_id) REFERENCES restaurants(id) ON DELETE CASCADE
            )
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS checklist_items (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                restaurant_id INTEGER NOT NULL,
                role TEXT NOT NULL,
                shift_type TEXT NOT NULL,
                text TEXT NOT NULL,
                FOREIGN KEY (restaurant_id) REFERENCES restaurants(id) ON DELETE CASCADE
            )
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS reminders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                restaurant_id INTEGER NOT NULL,
                role TEXT NOT NULL,
                text TEXT NOT NULL,
                interval_hours INTEGER NOT NULL,
                FOREIGN KEY (restaurant_id) REFERENCES restaurants(id) ON DELETE CASCADE
            )
        """)

        await db.execute("""
            CREATE TABLE IF NOT EXISTS invites (
                code TEXT PRIMARY KEY,
                restaurant_id INTEGER NOT NULL,
                role TEXT NOT NULL,
                is_used BOOLEAN DEFAULT 0,
                FOREIGN KEY (restaurant_id) REFERENCES restaurants(id) ON DELETE CASCADE
            )
        """)
        
        await db.commit()

==================== FILE: ./app/database/connection.py ====================

import aiosqlite
from typing import List, Dict, Any, Optional
from app.core.config import DB_PATH

async def _get_db():
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        yield db

async def execute(query: str, params: tuple = (), commit: bool = True) -> int:
    """–í—ã–ø–æ–ª–Ω—è–µ—Ç –∑–∞–ø—Ä–æ—Å INSERT/UPDATE/DELETE"""
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(query, params)
        if commit:
            await db.commit()
        return cursor.lastrowid

async def fetch_one(query: str, params: tuple = ()) -> Optional[Dict[str, Any]]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É –≤ –≤–∏–¥–µ —Å–ª–æ–≤–∞—Ä—è"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(query, params) as cursor:
            row = await cursor.fetchone()
            return dict(row) if row else None

async def fetch_all(query: str, params: tuple = ()) -> List[Dict[str, Any]]:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å—Ç—Ä–æ–∫ –≤ –≤–∏–¥–µ —Å–ª–æ–≤–∞—Ä–µ–π"""
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(query, params) as cursor:
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]

==================== FILE: ./app/database/repo/tasks.py ====================

import aiosqlite
from typing import List, Dict, Optional
from app.core.config import DB_PATH

async def create_personal_task_with_deadline(text: str, reward: int, deadline: str, tg_id: int, restaurant_id: int) -> int:
    async with aiosqlite.connect(DB_PATH) as db:
        cursor = await db.execute(
            """INSERT INTO extra_tasks (restaurant_id, text, reward, deadline, assigned_to, status) 
               VALUES (?, ?, ?, ?, ?, 'pending')""", 
            (restaurant_id, text, reward, deadline, tg_id)
        )
        await db.commit()
        return cursor.lastrowid

async def set_task_message_id(task_id: int, message_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("UPDATE extra_tasks SET message_id = ? WHERE id = ?", (message_id, task_id))
        await db.commit()

async def mark_task_completed(task_id: int, restaurant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE extra_tasks SET status = 'completed' WHERE id = ? AND restaurant_id = ?", 
            (task_id, restaurant_id)
        )
        await db.commit()

async def get_task_details(task_id: int, restaurant_id: int) -> Optional[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM extra_tasks WHERE id = ? AND restaurant_id = ?", 
            (task_id, restaurant_id)
        ) as cur:
            row = await cur.fetchone()
            return dict(row) if row else None

async def get_tasks_history(restaurant_id: int, limit: int = 10) -> List[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("""
            SELECT t.id, t.text, t.reward, t.status, u.full_name 
            FROM extra_tasks t
            LEFT JOIN users u ON t.assigned_to = u.tg_id AND t.restaurant_id = u.restaurant_id
            WHERE t.restaurant_id = ?
            ORDER BY t.id DESC LIMIT ?
        """, (restaurant_id, limit)) as cur:
            return [dict(row) for row in await cur.fetchall()]

async def add_bonus(tg_id: int, restaurant_id: int, amount: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE users SET balance = COALESCE(balance, 0) + ? WHERE tg_id = ? AND restaurant_id = ?", 
            (amount, tg_id, restaurant_id)
        )
        await db.commit()

async def get_balance(tg_id: int, restaurant_id: int) -> int:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute(
            "SELECT balance FROM users WHERE tg_id = ? AND restaurant_id = ?", 
            (tg_id, restaurant_id)
        ) as cur:
            row = await cur.fetchone()
            return row[0] if row else 0
        
async def get_pending_tasks_details(restaurant_id: int) -> List[dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("""
            SELECT t.id, t.text, t.assigned_to, t.message_id, u.full_name 
            FROM extra_tasks t
            JOIN users u ON t.assigned_to = u.tg_id AND t.restaurant_id = u.restaurant_id
            WHERE t.status = 'pending' AND t.restaurant_id = ?
            ORDER BY t.id DESC
        """, (restaurant_id,)) as cur:
            return [dict(row) for row in await cur.fetchall()]

async def cancel_task_in_db(task_id: int, restaurant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE extra_tasks SET status = 'canceled' WHERE id = ? AND restaurant_id = ?", 
            (task_id, restaurant_id)
        )
        await db.commit()

async def reset_balance(tg_id: int, restaurant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE users SET balance = 0 WHERE tg_id = ? AND restaurant_id = ?", 
            (tg_id, restaurant_id)
        )
        await db.commit()

==================== FILE: ./app/database/repo/users.py ====================

import aiosqlite
import hashlib
from datetime import datetime
from typing import Optional, List, Dict
from app.core.config import DB_PATH, TZ

def hash_pin(pin: str) -> str:
    return hashlib.sha256(pin.encode()).hexdigest()

async def add_user(tg_id: int, restaurant_id: int, full_name: str, role: str, pin: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("""
            INSERT INTO users (tg_id, restaurant_id, full_name, role, pin_hash, is_active)
            VALUES (?, ?, ?, ?, ?, 1)
            ON CONFLICT(tg_id, restaurant_id) DO UPDATE SET 
                full_name=excluded.full_name, role=excluded.role, pin_hash=excluded.pin_hash, is_active=1
        """, (tg_id, restaurant_id, full_name, role, hash_pin(pin)))
        await db.commit()

async def get_user(tg_id: int, restaurant_id: int) -> Optional[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM users WHERE tg_id = ? AND restaurant_id = ?", 
            (tg_id, restaurant_id)
        ) as cur:
            row = await cur.fetchone()
            return dict(row) if row else None

async def get_user_restaurants(tg_id: int) -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("""
            SELECT r.id, r.title, u.role 
            FROM users u
            JOIN restaurants r ON u.restaurant_id = r.id
            WHERE u.tg_id = ? AND u.is_active = 1 AND r.is_active = 1
        """, (tg_id,)) as cur:
            return [dict(row) for row in await cur.fetchall()]

async def get_all_users(restaurant_id: int) -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM users WHERE restaurant_id = ? ORDER BY role", 
            (restaurant_id,)
        ) as cur:
            return [dict(row) for row in await cur.fetchall()]

async def delete_user(tg_id: int, restaurant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE users SET is_active=0 WHERE tg_id=? AND restaurant_id=?", 
            (tg_id, restaurant_id)
        )
        await db.commit()

async def get_admins_ids(restaurant_id: int) -> List[int]:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute(
            "SELECT tg_id FROM users WHERE role = 'admin' AND restaurant_id = ?", 
            (restaurant_id,)
        ) as cur:
            return [row[0] for row in await cur.fetchall()]

async def create_session(tg_id: int, restaurant_id: int, role: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT OR REPLACE INTO sessions (user_id, active_restaurant_id, role) VALUES (?, ?, ?)", 
            (tg_id, restaurant_id, role)
        )
        await db.commit()

async def get_session_info(tg_id: int) -> Optional[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT active_restaurant_id, role FROM sessions WHERE user_id = ?", (tg_id,)) as cur:
            row = await cur.fetchone()
            return dict(row) if row else None

async def delete_session(tg_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM sessions WHERE user_id = ?", (tg_id,))
        await db.commit()

async def reset_user_kpi_date(tg_id: int, restaurant_id: int):
    now_str = datetime.now(TZ).strftime("%Y-%m-%d %H:%M:%S")
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE users SET kpi_reset_at = ? WHERE tg_id = ? AND restaurant_id = ?", 
            (now_str, tg_id, restaurant_id)
        )
        await db.commit()

async def fully_delete_user(tg_id: int, restaurant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM sessions WHERE user_id = ? AND active_restaurant_id = ?", (tg_id, restaurant_id))
        await db.execute("DELETE FROM extra_tasks WHERE assigned_to = ? AND restaurant_id = ?", (tg_id, restaurant_id))
        await db.execute("DELETE FROM shifts WHERE user_id = ? AND restaurant_id = ?", (tg_id, restaurant_id))
        await db.execute("DELETE FROM users WHERE tg_id = ? AND restaurant_id = ?", (tg_id, restaurant_id))
        await db.commit()

async def get_session_role(tg_id: int) -> Optional[str]:
    info = await get_session_info(tg_id)
    return info['role'] if info else None

==================== FILE: ./app/database/repo/roles.py ====================

import aiosqlite
from typing import List, Dict, Optional
from app.core.config import DB_PATH

async def get_all_roles(restaurant_id: int) -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM roles WHERE restaurant_id = ?", 
            (restaurant_id,)
        ) as cur:
            return [dict(row) for row in await cur.fetchall()]

async def get_role(restaurant_id: int, slug: str) -> Optional[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT * FROM roles WHERE restaurant_id = ? AND slug = ?", 
            (restaurant_id, slug)
        ) as cur:
            row = await cur.fetchone()
            return dict(row) if row else None

async def add_role(restaurant_id: int, slug: str, name: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT OR IGNORE INTO roles (slug, restaurant_id, name) VALUES (?, ?, ?)", 
            (slug, restaurant_id, name)
        )
        await db.commit()

async def update_role_name(restaurant_id: int, slug: str, new_name: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE roles SET name = ? WHERE restaurant_id = ? AND slug = ?", 
            (new_name, restaurant_id, slug)
        )
        await db.commit()

async def delete_role(restaurant_id: int, slug: str):
    if slug == 'admin': return 
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "DELETE FROM roles WHERE restaurant_id = ? AND slug = ?", 
            (restaurant_id, slug)
        )
        await db.commit()

async def get_roles_map(restaurant_id: int) -> Dict[str, str]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute(
            "SELECT slug, name FROM roles WHERE restaurant_id = ?", 
            (restaurant_id,)
        ) as cur:
            rows = await cur.fetchall()
            return {row['slug']: row['name'] for row in rows}

==================== FILE: ./app/database/repo/shifts.py ====================

import aiosqlite
from datetime import datetime
from typing import Optional, Dict, List
from app.core.config import DB_PATH, TZ

def now():
    return datetime.now(TZ).strftime("%Y-%m-%d %H:%M:%S")

async def start_shift(tg_id: int, restaurant_id: int, role: str, shift_type: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO shifts (user_id, restaurant_id, role, shift_type, started_at) VALUES (?, ?, ?, ?, ?)", 
            (tg_id, restaurant_id, role, shift_type, now())
        )
        await db.commit()

async def get_active_shift(tg_id: int, restaurant_id: int) -> Optional[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("""
            SELECT * FROM shifts 
            WHERE user_id = ? AND restaurant_id = ? AND ended_at IS NULL 
            ORDER BY id DESC LIMIT 1
        """, (tg_id, restaurant_id)) as cur:
            row = await cur.fetchone()
            return dict(row) if row else None

async def end_shift(shift_id: int, restaurant_id: int, report_json: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE shifts SET ended_at = ?, report = ? WHERE id = ? AND restaurant_id = ?", 
            (now(), report_json, shift_id, restaurant_id)
        )
        await db.commit()

async def update_shift_report(shift_id: int, restaurant_id: int, report_json: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "UPDATE shifts SET report = ? WHERE id = ? AND restaurant_id = ?", 
            (report_json, shift_id, restaurant_id)
        )
        await db.commit()

async def get_last_shifts(tg_id: int, restaurant_id: int, limit: int = 5) -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("""
            SELECT * FROM shifts 
            WHERE user_id = ? AND restaurant_id = ? AND ended_at IS NOT NULL 
            ORDER BY id DESC LIMIT ?
        """, (tg_id, restaurant_id, limit)) as cur:
            return [dict(row) for row in await cur.fetchall()]

async def get_all_active_shifts_data(restaurant_id: int) -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("""
            SELECT s.*, u.full_name 
            FROM shifts s
            JOIN users u ON s.user_id = u.tg_id AND s.restaurant_id = u.restaurant_id
            WHERE s.ended_at IS NULL AND s.restaurant_id = ?
        """, (restaurant_id,)) as cur:
            return [dict(row) for row in await cur.fetchall()]

async def get_monthly_stats(tg_id: int, restaurant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("""
            SELECT * FROM shifts 
            WHERE user_id = ? 
            AND restaurant_id = ?
            AND ended_at IS NOT NULL
            AND started_at >= COALESCE(
                (SELECT kpi_reset_at FROM users WHERE tg_id = ? AND restaurant_id = ?), 
                date('now', '-30 days')
            )
        """, (tg_id, restaurant_id, tg_id, restaurant_id)) as cur:
            return [dict(row) for row in await cur.fetchall()]

==================== FILE: ./app/database/repo/saas.py ====================

import uuid
import aiosqlite
from typing import List, Dict, Optional
from app.core.config import DB_PATH

async def create_license_key(admin_id: int, target_username: Optional[str] = None) -> str:
    key = f"LICENSE-{uuid.uuid4().hex[:8].upper()}"
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO license_keys (key_code, activated_by_tg_id, target_username) VALUES (?, ?, ?)",
            (key, admin_id, target_username)
        )
        await db.commit()
    return key

async def get_license_key(key_code: str):
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT * FROM license_keys WHERE key_code = ?", (key_code,)) as cur:
            row = await cur.fetchone()
            return dict(row) if row else None

async def register_new_restaurant(title: str, owner_tg_id: int, owner_username: Optional[str], owner_name: str, pin_hash: str, key_code: str) -> bool:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT * FROM license_keys WHERE key_code = ?", (key_code,)) as cur:
            row = await cur.fetchone()
            if not row or row['is_used']: return False
            if row['target_username']:
                clean_target = row['target_username'].lstrip('@').lower()
                clean_owner = owner_username.lower() if owner_username else ""
                if clean_target != clean_owner: return False

        async with db.execute("INSERT INTO restaurants (title, owner_tg_id, is_active) VALUES (?, ?, 1)", (title, owner_tg_id)) as cursor:
            restaurant_id = cursor.lastrowid

        await db.execute("INSERT INTO roles (slug, restaurant_id, name) VALUES (?, ?, ?)", ("admin", restaurant_id, "–í–ª–∞–¥–µ–ª–µ—Ü"))
        await db.execute("INSERT INTO users (tg_id, restaurant_id, full_name, role, pin_hash, is_active) VALUES (?, ?, ?, ?, ?, 1)", (owner_tg_id, restaurant_id, owner_name, "admin", pin_hash))
        await db.execute("UPDATE license_keys SET is_used = 1, activated_at = CURRENT_TIMESTAMP WHERE key_code = ?", (key_code,))
        await db.execute("INSERT OR REPLACE INTO sessions (user_id, active_restaurant_id, role) VALUES (?, ?, ?)", (owner_tg_id, restaurant_id, "admin"))
        await db.commit()
        return True

async def delete_restaurant(restaurant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("DELETE FROM sessions WHERE active_restaurant_id = ?", (restaurant_id,))
        await db.execute("DELETE FROM restaurants WHERE id = ?", (restaurant_id,))
        await db.commit()

async def get_restaurant_info(restaurant_id: int) -> Optional[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT * FROM restaurants WHERE id = ?", (restaurant_id,)) as cur:
            row = await cur.fetchone()
            return dict(row) if row else None

async def get_restaurant_users(restaurant_id: int) -> List[int]:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT tg_id FROM users WHERE restaurant_id = ?", (restaurant_id,)) as cur:
            rows = await cur.fetchall()
            return [r[0] for r in rows]

async def get_platform_stats() -> Dict:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT COUNT(*) FROM restaurants") as c:
            cafes = (await c.fetchone())[0]
        async with db.execute("SELECT COUNT(*) FROM users") as c:
            users = (await c.fetchone())[0]
        async with db.execute("SELECT COUNT(*) FROM shifts WHERE ended_at IS NULL") as c:
            shifts = (await c.fetchone())[0]
    return {"cafes": cafes, "users": users, "shifts": shifts}

async def get_all_restaurants() -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT id, title, is_active FROM restaurants ORDER BY id DESC") as cur:
            return [dict(row) for row in await cur.fetchall()]

async def toggle_restaurant_status(restaurant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT is_active FROM restaurants WHERE id = ?", (restaurant_id,)) as cur:
            row = await cur.fetchone()
            if not row: return None
            status = row[0]
        
        new_status = 0 if status else 1
        await db.execute("UPDATE restaurants SET is_active = ? WHERE id = ?", (new_status, restaurant_id))
        
        if new_status == 0:
            await db.execute("DELETE FROM sessions WHERE active_restaurant_id = ?", (restaurant_id,))
            
        await db.commit()
        return new_status

async def is_restaurant_active(restaurant_id: int) -> bool:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT is_active FROM restaurants WHERE id = ?", (restaurant_id,)) as cur:
            row = await cur.fetchone()
            return bool(row[0]) if row else False

async def get_all_owners_ids() -> List[int]:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute("SELECT DISTINCT owner_tg_id FROM restaurants") as cur:
            rows = await cur.fetchall()
            return [r[0] for r in rows]

==================== FILE: ./app/database/repo/checklists.py ====================

import aiosqlite
import uuid
from typing import List, Dict
from app.core.config import DB_PATH

async def get_checklist(restaurant_id: int, role: str, shift_type: str) -> List[str]:
    async with aiosqlite.connect(DB_PATH) as db:
        if shift_type == 'full':
            types = ('morning', 'common', 'evening')
        elif shift_type == 'morning':
            types = ('morning', 'common')
        elif shift_type == 'evening':
            types = ('common', 'evening')
        else:
            types = ('common',)

        placeholders = ','.join(['?'] * len(types))
        
        query = f"""
            SELECT text FROM checklist_items 
            WHERE restaurant_id = ? AND role = ? AND shift_type IN ({placeholders})
            ORDER BY CASE shift_type 
                WHEN 'morning' THEN 1 
                WHEN 'common' THEN 2 
                WHEN 'evening' THEN 3 
            END, id ASC
        """
        params = (restaurant_id, role, *types)

        async with db.execute(query, params) as cur:
            rows = await cur.fetchall()
            return [r[0] for r in rows]

async def add_checklist_item(restaurant_id: int, role: str, shift_type: str, text: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO checklist_items (restaurant_id, role, shift_type, text) VALUES (?, ?, ?, ?)", 
            (restaurant_id, role, shift_type, text)
        )
        await db.commit()

async def is_checklist_item_exists(restaurant_id: int, role: str, shift_type: str, text: str) -> bool:
    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute(
            "SELECT 1 FROM checklist_items WHERE restaurant_id = ? AND role = ? AND shift_type = ? AND text = ?", 
            (restaurant_id, role, shift_type, text)
        ) as cur:
            return await cur.fetchone() is not None

async def delete_checklist_item(item_id: int, restaurant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "DELETE FROM checklist_items WHERE id = ? AND restaurant_id = ?", 
            (item_id, restaurant_id)
        )
        await db.commit()

async def get_items_by_type(restaurant_id: int, role: str, shift_type: str) -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("""
            SELECT * FROM checklist_items 
            WHERE restaurant_id = ? AND role = ? AND shift_type = ?
            ORDER BY id ASC
        """, (restaurant_id, role, shift_type)) as cur:
            return [dict(row) for row in await cur.fetchall()]

async def add_reminder(restaurant_id: int, role: str, text: str, interval: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO reminders (restaurant_id, role, text, interval_hours) VALUES (?, ?, ?, ?)",
            (restaurant_id, role, text, interval)
        )
        await db.commit()

async def delete_reminder(rem_id: int, restaurant_id: int):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "DELETE FROM reminders WHERE id = ? AND restaurant_id = ?", 
            (rem_id, restaurant_id)
        )
        await db.commit()
        
async def get_all_reminders(restaurant_id: int) -> List[Dict]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT * FROM reminders WHERE restaurant_id = ?", (restaurant_id,)) as cur:
            return [dict(row) for row in await cur.fetchall()]

async def create_invite(restaurant_id: int, role: str) -> str:
    code = str(uuid.uuid4())[:8]
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute(
            "INSERT INTO invites (code, restaurant_id, role) VALUES (?, ?, ?)", 
            (code, restaurant_id, role)
        )
        await db.commit()
    return code

async def check_invite(code: str):
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        async with db.execute("SELECT * FROM invites WHERE code = ? AND is_used = 0", (code,)) as cur:
            row = await cur.fetchone()
            return dict(row) if row else None

async def mark_invite_used(code: str):
    async with aiosqlite.connect(DB_PATH) as db:
        await db.execute("UPDATE invites SET is_used = 1 WHERE code = ?", (code,))
        await db.commit()

==================== FILE: ./app/core/config.py ====================

import os
from pathlib import Path
from dotenv import load_dotenv
import pytz

load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent

BOT_TOKEN = os.getenv("BOT_TOKEN")

SUPER_ADMIN_PASSWORD = os.getenv("SUPER_ADMIN_PASSWORD", "root") 

DB_PATH = BASE_DIR / "saas.db"

WEB_APP_URL = "https://akku-2325.github.io/coffee-frontend/frontend/?update=1"
TZ = pytz.timezone("Asia/Almaty")

==================== FILE: ./app/core/scheduler.py ====================

import aiosqlite
import asyncio
from datetime import datetime
from aiogram import Bot
from app.core.config import DB_PATH, TZ

async def send_hourly_reminders(bot: Bot):
    try:
        now = datetime.now(TZ).replace(tzinfo=None)
        
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            
            async with db.execute("""
                SELECT s.user_id, s.restaurant_id, s.role, s.started_at 
                FROM shifts s
                WHERE s.ended_at IS NULL
            """) as cur:
                active_shifts = [dict(row) for row in await cur.fetchall()]

            if not active_shifts: return

            async with db.execute("SELECT * FROM reminders") as cur:
                all_reminders = [dict(row) for row in await cur.fetchall()]

        if not all_reminders: return

        for shift in active_shifts:
            try:
                tg_id = shift['user_id']
                r_id = shift['restaurant_id']
                role_slug = shift['role']
                
                start_time = datetime.strptime(shift['started_at'], "%Y-%m-%d %H:%M:%S")
                diff_min = int((now - start_time).total_seconds() // 60)

                relevant_reminders = [
                    rem for rem in all_reminders 
                    if rem['restaurant_id'] == r_id and rem['role'] == role_slug
                ]

                for r in relevant_reminders:
                    interval = r['interval_hours']
                    if interval > 0 and diff_min > 0 and (diff_min % interval == 0):
                        try:
                            await bot.send_message(tg_id, f"üîî <b>–ù–ê–ü–û–ú–ò–ù–ê–ù–ò–ï:</b>\n\n{r['text']}")
                            await asyncio.sleep(0.1) 
                        except Exception as e:
                            print(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å (user {tg_id}): {e}")

            except Exception as e:
                print(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π: {e}")
                continue

    except Exception as e:
        print(f"–ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ —à–µ–¥—É–ª–µ—Ä–∞: {e}")

async def clean_expired_tasks(bot: Bot):
    try:
        now_str = datetime.now(TZ).strftime("%Y-%m-%d %H:%M:%S")
        async with aiosqlite.connect(DB_PATH) as db:
            async with db.execute("""
                SELECT t.id, t.text, t.reward, t.assigned_to, t.message_id, t.restaurant_id, u.full_name
                FROM extra_tasks t
                JOIN users u ON t.assigned_to = u.tg_id AND t.restaurant_id = u.restaurant_id
                WHERE t.status = 'pending' AND t.deadline < ?
            """, (now_str,)) as cur:
                expired_tasks = await cur.fetchall()

            if not expired_tasks: return

            for task in expired_tasks:
                tid, text, reward, uid, mid, rid, name = task
                
                await db.execute("UPDATE extra_tasks SET status = 'expired' WHERE id = ?", (tid,))
                
                if mid:
                    try:
                        await bot.edit_message_text(
                            chat_id=uid,
                            message_id=mid,
                            text=f"üö´ <b>–í–†–ï–ú–Ø –ò–°–¢–ï–ö–õ–û!</b>\nüìù {text}\n‚ùå –ó–∞–¥–∞–Ω–∏–µ –ø—Ä–æ–≤–∞–ª–µ–Ω–æ.",
                            reply_markup=None
                        )
                    except: pass
                
                async with db.execute("SELECT tg_id FROM users WHERE role = 'admin' AND restaurant_id = ?", (rid,)) as acur:
                    admins = [row[0] for row in await acur.fetchall()]

                admin_msg = f"‚ùå <b>–ü–†–û–°–†–û–ß–ï–ù–û (–ê–≤—Ç–æ)</b>\nüë§ –ö—Ç–æ: {name}\nüìù –ó–∞–¥–∞—á–∞: {text}\nüí∞ –ü–æ—Ç–µ—Ä—è–Ω–æ: {reward} –±–∞–ª–ª–æ–≤"
                
                for a_id in admins:
                    try: await bot.send_message(a_id, admin_msg)
                    except: pass
            
            await db.commit()

    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –≤ clean_expired_tasks: {e}")

==================== FILE: ./app/keyboards/builders.py ====================

from aiogram.utils.keyboard import InlineKeyboardBuilder

def staff_list(users, current_user_id, roles_map):
    builder = InlineKeyboardBuilder()
    for u in users:
        if not u['is_active']: continue
        r_name = roles_map.get(u['role'], u['role'])
        builder.button(text=f"{u['full_name']} ‚Äî {r_name}", callback_data=f"open_staff:{u['tg_id']}")
    builder.button(text="üîΩ –ó–∞–∫—Ä—ã—Ç—å", callback_data="close_checklist")
    builder.adjust(1)
    return builder.as_markup()

def employee_actions(user_id, user_name):
    builder = InlineKeyboardBuilder()
    builder.button(text="üìä KPI –∏ –í—ã–ø–ª–∞—Ç–∞", callback_data=f"kpi:{user_id}")
    builder.button(text="üîÑ –ù–æ–≤—ã–π –ø–µ—Ä–∏–æ–¥ (–°–±—Ä–æ—Å)", callback_data=f"reset_stats:{user_id}")
    builder.button(text="üí∞ –®—Ç—Ä–∞—Ñ / –ü—Ä–µ–º–∏—è", callback_data=f"money:{user_id}")
    builder.button(text="‚ùå –£–¥–∞–ª–∏—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞", callback_data=f"fire:{user_id}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="back_to_staff")
    builder.adjust(1)
    return builder.as_markup()

def active_shifts_menu(shifts, roles_map=None):
    if roles_map is None: roles_map = {}
    builder = InlineKeyboardBuilder()
    for shift in shifts:
        r_name = roles_map.get(shift['role'], shift['role'])
        builder.button(text=f"üë§ {shift['full_name']} ({r_name})", callback_data=f"monitor:{shift['user_id']}")
    builder.button(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="refresh_monitor")
    builder.button(text="üîΩ –ó–∞–∫—Ä—ã—Ç—å", callback_data="close_checklist")
    builder.adjust(1)
    return builder.as_markup()

def dynamic_role_select(roles: list, prefix: str, show_admin: bool = False):
    builder = InlineKeyboardBuilder()
    for role in roles:
        if role['slug'] == 'admin' and not show_admin: continue
        builder.button(text=f"{role['name']}", callback_data=f"{prefix}:{role['slug']}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="back_to_admin")
    builder.adjust(2)
    return builder.as_markup()

def checklist_categories(role_slug):
    builder = InlineKeyboardBuilder()
    builder.button(text="üåÖ –£—Ç—Ä–æ", callback_data=f"open_cat:{role_slug}:morning")
    builder.button(text="üîÑ –û–±—â–µ–µ", callback_data=f"open_cat:{role_slug}:common")
    builder.button(text="üåá –í–µ—á–µ—Ä", callback_data=f"open_cat:{role_slug}:evening")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="settings_checklists")
    builder.adjust(1)
    return builder.as_markup()

def checklist_items_edit(items: list, role_slug: str, shift_type: str, mode: str = "view", selected_ids: list = None, page: int = 0):
    if selected_ids is None: selected_ids = []
    
    ITEMS_PER_PAGE = 8
    
    builder = InlineKeyboardBuilder()

    if mode == "view":
        builder.button(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∑–∞–¥–∞—á—É", callback_data=f"add_item:{role_slug}:{shift_type}")
        builder.button(text="üóë –£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á–∏", callback_data=f"mode_del:{role_slug}:{shift_type}")
        builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data=f"edit_cl:{role_slug}")
        builder.button(text="üè† –ó–∞–∫–æ–Ω—á–∏—Ç—å", callback_data="back_to_admin")
        builder.adjust(1)
        return builder.as_markup()
        
    elif mode == "delete":
        total_items = len(items)
        start_index = page * ITEMS_PER_PAGE
        end_index = start_index + ITEMS_PER_PAGE
        page_items = items[start_index:end_index]
        
        for item in page_items:
            icon = "‚úÖ" if item['id'] in selected_ids else "‚¨ú"
            short_text = item['text'][:15] + ".." if len(item['text']) > 15 else item['text']
            
            builder.button(
                text=f"{icon} {short_text}", 
                callback_data=f"toggle_sel:{item['id']}:{role_slug}:{shift_type}"
            )
        
        builder.adjust(2)

        nav_builder = InlineKeyboardBuilder()
        total_pages = (total_items + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE
        
        if total_pages > 1:
            if page > 0:
                nav_builder.button(text="‚¨ÖÔ∏è", callback_data=f"cl_page:{page-1}:{role_slug}:{shift_type}")
            else:
                nav_builder.button(text="‚ñ´Ô∏è", callback_data="noop")
            
            nav_builder.button(text=f"{page + 1}/{total_pages}", callback_data="noop")
            
            if end_index < total_items:
                nav_builder.button(text="‚û°Ô∏è", callback_data=f"cl_page:{page+1}:{role_slug}:{shift_type}")
            else:
                nav_builder.button(text="‚ñ´Ô∏è", callback_data="noop")
                
            nav_builder.adjust(3)
            builder.attach(nav_builder)

        control = InlineKeyboardBuilder()
        if selected_ids:
            control.button(text=f"üóë –£–¥–∞–ª–∏—Ç—å ({len(selected_ids)})", callback_data=f"confirm_del:{role_slug}:{shift_type}")
        control.button(text="üîô –û—Ç–º–µ–Ω–∞", callback_data=f"open_cat:{role_slug}:{shift_type}")
        control.adjust(1)
        
        builder.attach(control)

    return builder.as_markup()

def task_assign_menu(users, current_user_id, active_ids, roles_map):
    builder = InlineKeyboardBuilder()
    for u in users:
        if u['tg_id'] == current_user_id or not u['is_active']: continue
        status = "üü¢" if u['tg_id'] in active_ids else "üí§"
        r_name = roles_map.get(u['role'], u['role'])
        builder.button(text=f"{status} {u['full_name']} ({r_name})", callback_data=f"assign:{u['tg_id']}")
    builder.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel_task")
    builder.adjust(1)
    return builder.as_markup()

def reminders_list_menu(reminders: list, roles_map: dict):
    builder = InlineKeyboardBuilder()
    for r in reminders:
        r_name = roles_map.get(r['role'], r['role'])
        builder.button(text=f"‚ùå {r_name}: {r['text'][:15]}...", callback_data=f"del_remind:{r['id']}")
    builder.button(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å", callback_data="add_reminder_start")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="back_to_admin")
    builder.adjust(1)
    return builder.as_markup()

def back_to_monitor():
    builder = InlineKeyboardBuilder()
    builder.button(text="üîô –ö —Å–ø–∏—Å–∫—É", callback_data="refresh_monitor")
    return builder.as_markup()

def delete_role_select(roles: list):
    builder = InlineKeyboardBuilder()
    for role in roles:
        if role['slug'] == 'admin': continue
        builder.button(text=f"üóë {role['name']}", callback_data=f"del_role_db:{role['slug']}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="back_to_admin")
    builder.adjust(1)
    return builder.as_markup()

def confirm_delete_role_menu(role_slug):
    builder = InlineKeyboardBuilder()
    builder.button(text="üóë –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data=f"confirm_del_role:{role_slug}")
    builder.button(text="üîô –ù–µ—Ç, –æ—Ç–º–µ–Ω–∞", callback_data="cancel_del_role")
    builder.adjust(1)
    return builder.as_markup()

def checklist_kb(status_list: list, shift_id: int, tasks_list: list):
    builder = InlineKeyboardBuilder()
    for i, task in enumerate(tasks_list):
        is_done = status_list[i] if i < len(status_list) else False
        text = f"‚úÖ {task}" if is_done else f"üü• {task}"
        callback_action = "check_off" if is_done else "check_on"
        builder.button(text=text, callback_data=f"{callback_action}:{i}:{shift_id}")
    builder.adjust(1)
    
    control_builder = InlineKeyboardBuilder()
    control_builder.button(text="üì§ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç—á–µ—Ç", callback_data=f"submit_checklist:{shift_id}")
    control_builder.button(text="üîΩ –°–∫—Ä—ã—Ç—å", callback_data="close_checklist")
    control_builder.adjust(1)
    
    builder.attach(control_builder)
    return builder.as_markup()

==================== FILE: ./app/keyboards/reply.py ====================

from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

def admin_main():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üëÄ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥")],
            [KeyboardButton(text="üë• –°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏"), KeyboardButton(text="üîó –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è")],
            [KeyboardButton(text="üìù –ó–∞–¥–∞–Ω–∏—è")],
            [KeyboardButton(text="‚öôÔ∏è –ß–µ–∫-–ª–∏—Å—Ç—ã"), KeyboardButton(text="üé≠ –†–æ–ª–∏")],
            [KeyboardButton(text="üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è"), KeyboardButton(text="üö™ –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω–∫–∏")]
        ],
        resize_keyboard=True
    )

def admin_roles_menu():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å —Ä–æ–ª—å"), KeyboardButton(text="üìù –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–æ–ª—å")],
            [KeyboardButton(text="‚ùå –£–¥–∞–ª–∏—Ç—å —Ä–æ–ª—å"), KeyboardButton(text="üîô –í –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")]
        ],
        resize_keyboard=True
    )

def guest():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="üîê –í–æ–π—Ç–∏")]], 
        resize_keyboard=True
    )

def login_cancel():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞ –≤–≤–æ–¥–∞")]],
        resize_keyboard=True
    )

def menu_shift_closed():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üü¢ –ù–∞—á–∞—Ç—å —Å–º–µ–Ω—É")],
            [KeyboardButton(text="üìú –ò—Å—Ç–æ—Ä–∏—è —Å–º–µ–Ω"), KeyboardButton(text="üí∞ –ú–æ–π –±–∞–ª–∞–Ω—Å")],
            [KeyboardButton(text="üö™ –í—ã–π—Ç–∏")]
        ],
        resize_keyboard=True
    )

def menu_shift_open(web_app_url: str):
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚ö°Ô∏è –û–Ω–ª–∞–π–Ω –ß–µ–∫-–ª–∏—Å—Ç")], 
            [KeyboardButton(text="üî¥ –ó–∞–∫–æ–Ω—á–∏—Ç—å —Å–º–µ–Ω—É")],
            [KeyboardButton(text="üìú –ò—Å—Ç–æ—Ä–∏—è —Å–º–µ–Ω"), KeyboardButton(text="üí∞ –ú–æ–π –±–∞–ª–∞–Ω—Å")],
        ],
        resize_keyboard=True
    )

def cancel():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞")]],
        resize_keyboard=True
    )

def comment_menu():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚û°Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å")],
            [KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞")]
        ],
        resize_keyboard=True
    )

def shift_type_kb():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üåÖ –£—Ç—Ä–µ–Ω–Ω—è—è"), KeyboardButton(text="üåá –í–µ—á–µ—Ä–Ω—è—è")],
            [KeyboardButton(text="üìÖ –ü–æ–ª–Ω—ã–π –¥–µ–Ω—å")],
            [KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞")]
        ],
        resize_keyboard=True
    )

def super_admin_panel():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üëë –ü–∞–Ω–µ–ª—å –í–ª–∞–¥–µ–ª—å—Ü–∞")],
            [KeyboardButton(text="üö™ –í—ã–π—Ç–∏ –∏–∑ —Å–∏—Å—Ç–µ–º—ã")]
        ],
        resize_keyboard=True
    )

==================== FILE: ./app/middlewares/saas.py ====================

import aiosqlite
from typing import Callable, Dict, Any, Awaitable
from aiogram import BaseMiddleware
from aiogram.types import Message, CallbackQuery
from app.core.config import DB_PATH

class SaasMiddleware(BaseMiddleware):
    async def __call__(
        self,
        handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]],
        event: Message | CallbackQuery,
        data: Dict[str, Any]
    ) -> Any:
        user_id = event.from_user.id
        
        async with aiosqlite.connect(DB_PATH) as db:
            db.row_factory = aiosqlite.Row
            async with db.execute("""
                SELECT s.active_restaurant_id, s.role, r.is_active 
                FROM sessions s
                LEFT JOIN restaurants r ON s.active_restaurant_id = r.id
                WHERE s.user_id = ?
            """, (user_id,)) as cur:
                row = await cur.fetchone()
                
                if row:
                    is_root_cmd = False
                    if isinstance(event, Message) and event.text:
                        if event.text.startswith("/root_login") or event.text == "üö™ –í—ã–π—Ç–∏":
                            is_root_cmd = True

                    if row["active_restaurant_id"] and not row["is_active"] and not is_root_cmd:
                        try:
                            if isinstance(event, Message):
                                await event.answer("‚ùÑÔ∏è <b>–í–∞—à–∞ –∫–æ—Ñ–µ–π–Ω—è –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–º–æ—Ä–æ–∂–µ–Ω–∞.</b>\n–û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –≤–ª–∞–¥–µ–ª—å—Ü—É –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã.")
                            elif isinstance(event, CallbackQuery):
                                await event.answer("‚ùÑÔ∏è –î–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω.", show_alert=True)
                        except: pass
                        return

                    data["restaurant_id"] = row["active_restaurant_id"]
                    data["role"] = row["role"]
                else:
                    data["restaurant_id"] = None
                    data["role"] = None

        return await handler(event, data)

==================== FILE: ./app/states/states.py ====================

from aiogram.fsm.state import State, StatesGroup

class RootState(StatesGroup):
    active = State()
    waiting_target_id = State()
    waiting_broadcast_text = State()

class OwnerReg(StatesGroup):
    waiting_key = State()
    waiting_title = State()
    waiting_name = State()
    waiting_pin = State()

class LoginState(StatesGroup):
    waiting_pin = State()

class RegState(StatesGroup):
    name = State()
    pin = State()

class TaskState(StatesGroup):
    waiting_text = State()
    waiting_reward = State()
    waiting_hours = State()
    waiting_employee = State()

class ShiftState(StatesGroup):
    waiting_for_shift_type = State()
    waiting_for_photo_start = State() 
    waiting_for_photo_end = State()
    waiting_checklist_comment = State() 
    waiting_end_comment = State()       

class MoneyState(StatesGroup):
    waiting_for_amount = State()
    waiting_for_reason = State()

class RoleState(StatesGroup):
    waiting_role_name = State()
    waiting_role_slug = State()
    waiting_new_role_name = State()

class ChecklistState(StatesGroup):
    waiting_checklist_text = State()

class ReminderState(StatesGroup):
    remind_role = State()
    remind_text = State()
    remind_interval = State()

==================== FILE: ./app/handlers/registration.py ====================

from aiogram import Router, F
from aiogram.types import Message
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.filters import CommandStart, StateFilter, CommandObject
from app.database.repo import saas as saas_repo
from app.database.repo import users as user_repo
from app.keyboards import reply

router = Router()

class OwnerReg(StatesGroup):
    waiting_key = State()
    waiting_title = State()
    waiting_name = State()
    waiting_pin = State()

@router.message(CommandStart(deep_link=True), F.text.contains("LICENSE-"), StateFilter("*"))
async def start_owner_registration(message: Message, state: FSMContext, command: CommandObject):
    args = command.args
    await state.clear() 

    key_data = await saas_repo.get_license_key(args)
    
    if not key_data: 
        return await message.answer("‚õî –ö–ª—é—á –ª–∏—Ü–µ–Ω–∑–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
    
    if key_data['is_used']:
        return await message.answer("‚ö†Ô∏è –≠—Ç–∞ –ª–∏—Ü–µ–Ω–∑–∏—è —É–∂–µ –±—ã–ª–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞.")

    current_username = message.from_user.username
    current_id = message.from_user.id
    
    if key_data['target_tg_id'] and key_data['target_tg_id'] != current_id:
         return await message.answer("‚õî –û–®–ò–ë–ö–ê: –°—Å—ã–ª–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")

    if key_data['target_username']:
        clean_target = key_data['target_username'].lstrip('@').lower()
        clean_current = current_username.lower() if current_username else ""
        if clean_target != clean_current:
            return await message.answer(f"‚õî –û–®–ò–ë–ö–ê: –°—Å—ã–ª–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è @{key_data['target_username']}.")

    await state.update_data(key=args)
    await process_key(message, args, state)

@router.message(OwnerReg.waiting_key)
async def key_input(message: Message, state: FSMContext):
    await process_key(message, message.text.strip(), state)

async def process_key(message: Message, key: str, state: FSMContext):
    key_data = await saas_repo.get_license_key(key)
    if not key_data or key_data['is_used']:
        return await message.answer("‚õî –ö–ª—é—á –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω.")
    
    await state.update_data(key=key)
    await state.set_state(OwnerReg.waiting_title)
    await message.answer("‚úÖ <b>–õ–∏—Ü–µ–Ω–∑–∏—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!</b>\n\n1Ô∏è‚É£ –í–≤–µ–¥–∏—Ç–µ <b>–Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–æ—Ñ–µ–π–Ω–∏</b>:")

@router.message(OwnerReg.waiting_title)
async def reg_title(message: Message, state: FSMContext):
    await state.update_data(title=message.text)
    await state.set_state(OwnerReg.waiting_name)
    await message.answer("2Ô∏è‚É£ –í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ <b>–ò–º—è</b> (–í–ª–∞–¥–µ–ª—å—Ü–∞):")

@router.message(OwnerReg.waiting_name)
async def reg_name(message: Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(OwnerReg.waiting_pin)
    await message.answer("3Ô∏è‚É£ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ <b>PIN-–∫–æ–¥</b> (4 —Ü–∏—Ñ—Ä—ã) –¥–ª—è –≤—Ö–æ–¥–∞:")

@router.message(OwnerReg.waiting_pin)
async def reg_pin(message: Message, state: FSMContext):
    if not message.text.isdigit() or len(message.text) != 4:
        return await message.answer("‚ùå PIN –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å 4 —Ü–∏—Ñ—Ä—ã.")
    
    data = await state.get_data()
    pin_hash = user_repo.hash_pin(message.text)
    
    success = await saas_repo.register_new_restaurant(
        data['title'], message.from_user.id, message.from_user.username, 
        data['name'], pin_hash, data['key']
    )
    
    await state.clear()
    
    if success:
        await message.answer(
            f"üéâ <b>–ö–æ—Ñ–µ–π–Ω—è ¬´{data['title']}¬ª —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
            f"–í—Ö–æ–¥ –¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ –∫–Ω–æ–ø–∫–µ –Ω–∏–∂–µ.",
            reply_markup=reply.guest() 
        )
    else:
        await message.answer("‚õî –û—à–∏–±–∫–∞: –õ–∏—Ü–µ–Ω–∑–∏—è –±—ã–ª–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞.", reply_markup=reply.guest())

==================== FILE: ./app/handlers/auth.py ====================

from aiogram import Router, F
from aiogram.filters import StateFilter, CommandStart, CommandObject, Command
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from app.core.config import WEB_APP_URL
from app.database.repo import users as user_repo
from app.database.repo import checklists as check_repo
from app.database.repo import roles as role_repo
from app.database.repo import shifts as shift_repo 
from app.services import auth as auth_service
from app.keyboards import reply
from app.states.states import RegState, LoginState

router = Router()

@router.message(CommandStart(deep_link=True), StateFilter("*"))
async def start_employee_invite(message: Message, command: CommandObject, state: FSMContext):
    invite_code = command.args
    await state.clear() 

    invite_data = await check_repo.check_invite(invite_code)
    if not invite_data:
        return await message.answer("‚õî –°—Å—ã–ª–∫–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –∏–ª–∏ —É—Å—Ç–∞—Ä–µ–ª–∞.")
    
    target_r_id = invite_data['restaurant_id']
    existing = await user_repo.get_user(message.from_user.id, target_r_id)
    if existing and existing['is_active']:
         return await message.answer("–í—ã —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —ç—Ç–æ–º –∑–∞–≤–µ–¥–µ–Ω–∏–∏! –ù–∞–∂–º–∏—Ç–µ '–í–æ–π—Ç–∏'.", reply_markup=reply.guest())

    role_info = await role_repo.get_role(target_r_id, invite_data['role'])
    role_name = role_info['name'] if role_info else invite_data['role']

    await state.update_data(role=invite_data['role'], code=invite_code, target_restaurant_id=target_r_id)
    await state.set_state(RegState.name)
    await message.answer(f"üëã –í–∞—Å –ø—Ä–∏–≥–ª–∞—Å–∏–ª–∏ –≤ –∫–æ–º–∞–Ω–¥—É!\n–î–æ–ª–∂–Ω–æ—Å—Ç—å: <b>{role_name}</b>\n\n1Ô∏è‚É£ –í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ <b>–ò–º—è –∏ –§–∞–º–∏–ª–∏—é</b>:")

@router.message(Command("start"), StateFilter("*"))
async def start_default(message: Message, state: FSMContext):
    await state.clear()
    
    shops = await user_repo.get_user_restaurants(message.from_user.id)
    
    if not shops:
        await message.answer(
            "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!\n\n"
            "‚Ä¢ –ï—Å–ª–∏ –≤—ã –≤–ª–∞–¥–µ–ª–µ—Ü: –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ <b>Magic Link</b> –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–æ—Ñ–µ–π–Ω–∏.\n"
            "‚Ä¢ –ï—Å–ª–∏ –≤—ã —Å–æ—Ç—Ä—É–¥–Ω–∏–∫: –ø–æ–ø—Ä–æ—Å–∏—Ç–µ <b>—Å—Å—ã–ª–∫—É-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ</b> —É –º–µ–Ω–µ–¥–∂–µ—Ä–∞.", 
            reply_markup=reply.guest()
        )
    else:
        await message.answer("üëã –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º! –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=reply.guest())


@router.message(RegState.name)
async def reg_name(message: Message, state: FSMContext):
    await state.update_data(name=message.text)
    await state.set_state(RegState.pin)
    await message.answer("2Ô∏è‚É£ –ü—Ä–∏–¥—É–º–∞–π—Ç–µ <b>PIN-–∫–æ–¥</b> (4 —Ü–∏—Ñ—Ä—ã) –¥–ª—è –≤—Ö–æ–¥–∞:")

@router.message(RegState.pin)
async def reg_pin(message: Message, state: FSMContext):
    if not message.text.isdigit() or len(message.text) != 4:
        return await message.answer("‚ùå PIN –¥–æ–ª–∂–µ–Ω —Å–æ—Å—Ç–æ—è—Ç—å –∏–∑ 4 —Ü–∏—Ñ—Ä.")
    data = await state.get_data()
    await user_repo.add_user(message.from_user.id, data['target_restaurant_id'], data['name'], data['role'], message.text)
    await check_repo.mark_invite_used(data['code'])
    await state.clear()
    await message.answer(f"‚úÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ù–∞–∂–º–∏—Ç–µ <b>üîê –í–æ–π—Ç–∏</b>.", reply_markup=reply.guest())


@router.message(F.text == "üîê –í–æ–π—Ç–∏")
async def login_start(message: Message, state: FSMContext):
    shops = await user_repo.get_user_restaurants(message.from_user.id)
    if not shops: return await message.answer("‚ö†Ô∏è –í—ã –Ω–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –Ω–∏–≥–¥–µ.")
    
    if len(shops) == 1:
        shop = shops[0]
        await state.update_data(target_restaurant_id=shop['id'])
        await state.set_state(LoginState.waiting_pin)
        return await message.answer(f"üè¢ <b>{shop['title']}</b>\nüî¢ –í–≤–µ–¥–∏—Ç–µ PIN-–∫–æ–¥:", reply_markup=reply.login_cancel())

    builder = InlineKeyboardBuilder()
    for s in shops: builder.button(text=f"üè¢ {s['title']}", callback_data=f"login_select:{s['id']}")
    builder.adjust(1)
    await message.answer("<b>–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–≤–µ–¥–µ–Ω–∏–µ –¥–ª—è –≤—Ö–æ–¥–∞:</b>", reply_markup=builder.as_markup())

@router.callback_query(F.data.startswith("login_select:"))
async def login_select_shop(callback: CallbackQuery, state: FSMContext):
    r_id = int(callback.data.split(":")[1])
    shops = await user_repo.get_user_restaurants(callback.from_user.id)
    shop = next((s for s in shops if s['id'] == r_id), None)
    
    if not shop: return await callback.answer("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞.")

    await state.update_data(target_restaurant_id=r_id)
    await state.set_state(LoginState.waiting_pin)
    await callback.message.edit_text(f"üè¢ <b>{shop['title']}</b>\nüî¢ –í–≤–µ–¥–∏—Ç–µ PIN-–∫–æ–¥:", reply_markup=None)
    await callback.message.answer("–í–≤–µ–¥–∏—Ç–µ –ü–ò–ù –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –æ—Ç–º–µ–Ω—É:", reply_markup=reply.login_cancel())
    await callback.answer()

@router.message(LoginState.waiting_pin, F.text == "‚ùå –û—Ç–º–µ–Ω–∞ –≤–≤–æ–¥–∞")
async def login_cancel_handler(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("–í—Ö–æ–¥ –æ—Ç–º–µ–Ω–µ–Ω.", reply_markup=reply.guest())

@router.message(LoginState.waiting_pin)
async def login_process(message: Message, state: FSMContext):
    data = await state.get_data()
    r_id = data.get('target_restaurant_id')
    
    if not r_id:
        await state.clear()
        return await message.answer("–û—à–∏–±–∫–∞ —Å–µ—Å—Å–∏–∏.", reply_markup=reply.guest())

    result = await auth_service.try_login(message.from_user.id, r_id, message.text.strip())
    
    if result == "disabled":
        await message.answer("‚õî –î–æ—Å—Ç—É–ø –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º.", reply_markup=reply.guest())
        await state.clear()
    elif result: 
        await state.clear()
        if result["role"] == "admin": 
            await message.answer("üï¥ –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—Ç–∫—Ä—ã—Ç–∞.", reply_markup=reply.admin_main())
        else:
            active_shift = await shift_repo.get_active_shift(message.from_user.id, r_id)
            if active_shift:
                await message.answer(f"‚úÖ –° –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ–º, {result['full_name']}!", reply_markup=reply.menu_shift_open(WEB_APP_URL))
            else:
                await message.answer(f"‚úÖ –ü—Ä–∏–≤–µ—Ç, {result['full_name']}!", reply_markup=reply.menu_shift_closed())
    else:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π PIN-–∫–æ–¥.")

@router.message(F.text.in_({"üö™ –í—ã–π—Ç–∏", "üö™ –í—ã–π—Ç–∏ –∏–∑ –∞–¥–º–∏–Ω–∫–∏"}))
async def logout_cmd(message: Message, state: FSMContext):
    await state.clear()
    await auth_service.logout(message.from_user.id)
    await message.answer("üëã –î–æ —Å–≤–∏–¥–∞–Ω–∏—è.", reply_markup=reply.guest())

==================== FILE: ./app/handlers/shifts.py ====================

import json
from datetime import datetime
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.filters import StateFilter

from app.core.config import WEB_APP_URL, TZ
from app.database.repo import users as user_repo
from app.database.repo import shifts as shift_repo
from app.database.repo import checklists as check_repo
from app.database.repo import roles as role_repo
from app.database.repo import tasks as task_repo 
from app.services import shift as shift_service
from app.keyboards import reply, builders
from app.states.states import ShiftState 

router = Router()

@router.message(StateFilter(ShiftState), F.text == "‚ùå –û—Ç–º–µ–Ω–∞")
async def cancel_shift_action(message: Message, state: FSMContext, restaurant_id: int):
    await state.clear()
    active = await shift_repo.get_active_shift(message.from_user.id, restaurant_id)
    if active:
        await message.answer("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=reply.menu_shift_open(WEB_APP_URL))
    else:
        await message.answer("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=reply.menu_shift_closed())


@router.message(F.text == "üü¢ –ù–∞—á–∞—Ç—å —Å–º–µ–Ω—É")
async def start_shift_ask_type(message: Message, state: FSMContext, restaurant_id: int):
    tg_id = message.from_user.id
    if await shift_repo.get_active_shift(tg_id, restaurant_id):
        return await message.answer("‚ö†Ô∏è –°–º–µ–Ω–∞ —É–∂–µ –∏–¥–µ—Ç!", reply_markup=reply.menu_shift_open(WEB_APP_URL))
    
    await state.set_state(ShiftState.waiting_for_shift_type)
    await message.answer("üìÖ <b>–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø —Å–º–µ–Ω—ã:</b>", reply_markup=reply.shift_type_kb())

@router.message(ShiftState.waiting_for_shift_type)
async def set_shift_type(message: Message, state: FSMContext):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await state.clear()
        return await message.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=reply.menu_shift_closed())
    
    type_map = {"üåÖ –£—Ç—Ä–µ–Ω–Ω—è—è": "morning", "üåá –í–µ—á–µ—Ä–Ω—è—è": "evening", "üìÖ –ü–æ–ª–Ω—ã–π –¥–µ–Ω—å": "full"}
    selected = type_map.get(message.text)
    
    if not selected: 
        return await message.answer("‚ùå –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –≤–Ω–∏–∑—É!")
    
    await state.update_data(shift_type=selected)
    await state.set_state(ShiftState.waiting_for_photo_start)
    await message.answer("üé• <b>–ó–∞–ø–∏—à–∏—Ç–µ –≤–∏–¥–µ–æ-–∫—Ä—É–∂–æ–∫</b> –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–º–µ–Ω—ã.", reply_markup=reply.cancel())

@router.message(ShiftState.waiting_for_photo_start, ~F.video_note)
async def start_wrong_media(message: Message):
    await message.answer("‚ùå <b>–û—à–∏–±–∫–∞!</b>\n–Ø –∂–¥—É <b>–í–ò–î–ï–û-–ö–†–£–ñ–û–ö</b>.\n–ó–∞–ø–∏—à–∏—Ç–µ –∫—Ä—É–∂–æ–∫ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–û—Ç–º–µ–Ω–∞¬ª.")

@router.message(ShiftState.waiting_for_photo_start, F.video_note)
async def start_shift_with_video(message: Message, state: FSMContext, restaurant_id: int):
    tg_id = message.from_user.id
    video_note_id = message.video_note.file_id
    
    user_info = await user_repo.get_user(tg_id, restaurant_id)
    if not user_info:
        await state.clear()
        return await message.answer("–û—à–∏–±–∫–∞: –°–æ—Ç—Ä—É–¥–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
    
    role = user_info['role']
    data = await state.get_data()
    shift_type = data.get('shift_type', 'full')
    
    await shift_repo.start_shift(tg_id, restaurant_id, role, shift_type)
    await message.answer("‚òÄÔ∏è <b>–°–º–µ–Ω–∞ –æ—Ç–∫—Ä—ã—Ç–∞!</b>", reply_markup=reply.menu_shift_open(WEB_APP_URL))
    await state.clear()
    
    roles_map = await role_repo.get_roles_map(restaurant_id)
    r_name = roles_map.get(role, role)
    type_rus = {"morning": "–£—Ç—Ä–æ", "evening": "–í–µ—á–µ—Ä", "full": "–ü–æ–ª–Ω–∞—è"}.get(shift_type, shift_type)
    time_now = datetime.now(TZ).strftime('%H:%M')

    for admin_id in await user_repo.get_admins_ids(restaurant_id):
        try:
            await message.bot.send_video_note(admin_id, video_note_id)
            await message.bot.send_message(admin_id, f"‚òÄÔ∏è <b>–°–ú–ï–ù–ê –û–¢–ö–†–´–¢–ê ({type_rus})</b>\nüë§ {user_info['full_name']} (<b>{r_name}</b>)\nüìÖ {time_now}")
        except: pass


@router.message(F.text == "‚ö°Ô∏è –û–Ω–ª–∞–π–Ω –ß–µ–∫-–ª–∏—Å—Ç")
async def open_live_checklist(message: Message, restaurant_id: int):
    tg_id = message.from_user.id
    active = await shift_repo.get_active_shift(tg_id, restaurant_id)
    if not active: return await message.answer("–°–º–µ–Ω–∞ –Ω–µ –æ—Ç–∫—Ä—ã—Ç–∞.")
    
    tasks_list = await check_repo.get_checklist(restaurant_id, active['role'], active['shift_type'])
    
    try:
        data = json.loads(active['report']) if active['report'] else {}
        user_duties = data.get('duties', [])
    except: 
        user_duties = []
    
    status_list = []
    for i in range(len(tasks_list)):
        if i < len(user_duties):
            status_list.append(user_duties[i].get('done', False))
        else:
            status_list.append(False)
    
    roles_map = await role_repo.get_roles_map(restaurant_id)
    r_name = roles_map.get(active['role'], active['role'])
    
    await message.answer(
        f"‚ö°Ô∏è <b>–ß–µ–∫-–ª–∏—Å—Ç: {r_name}</b>", 
        reply_markup=builders.checklist_kb(status_list, active['id'], tasks_list)
    )

@router.callback_query(F.data.startswith("check_"))
async def toggle_task_handler(callback: CallbackQuery, restaurant_id: int):
    parts = callback.data.split(":")
    action, index_str, btn_shift_id = parts[0], parts[1], int(parts[2])
    active = await shift_repo.get_active_shift(callback.from_user.id, restaurant_id)
    if not active or active['id'] != btn_shift_id: return await callback.answer("–°–º–µ–Ω–∞ –∑–∞–∫—Ä—ã—Ç–∞!", show_alert=True)
    
    tasks_list = await check_repo.get_checklist(restaurant_id, active['role'], active['shift_type'])
    
    if int(index_str) >= len(tasks_list):
        return await callback.answer("–°–ø–∏—Å–æ–∫ –∏–∑–º–µ–Ω–∏–ª—Å—è, –æ—Ç–∫—Ä–æ–π—Ç–µ –∑–∞–Ω–æ–≤–æ.")

    status_list = await shift_service.toggle_duty(callback.from_user.id, restaurant_id, int(index_str), (action == "check_on"), tasks_list)
    
    if status_list is not None:
        try: 
            await callback.message.edit_reply_markup(
                reply_markup=builders.checklist_kb(status_list, active['id'], tasks_list)
            )
        except: pass 

@router.callback_query(F.data.startswith("submit_checklist"))
async def submit_checklist_ask_comment(callback: CallbackQuery, state: FSMContext, restaurant_id: int):
    shift_id = int(callback.data.split(":")[1])
    active = await shift_repo.get_active_shift(callback.from_user.id, restaurant_id)
    if not active or active['id'] != shift_id: return await callback.answer("–°–º–µ–Ω–∞ –∑–∞–∫—Ä—ã—Ç–∞!", show_alert=True)
    
    await state.update_data(current_shift_id=shift_id)
    await state.set_state(ShiftState.waiting_checklist_comment)
    
    await callback.message.answer(
        "üìù <b>–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –æ—Ç—á–µ—Ç—É?</b>\n–ù–∞–ø–∏—à–∏—Ç–µ —Ç–µ–∫—Å—Ç –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å¬ª.",
        reply_markup=reply.comment_menu()
    )
    await callback.answer()

@router.message(ShiftState.waiting_checklist_comment)
async def submit_checklist_process(message: Message, state: FSMContext, restaurant_id: int):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await state.clear()
        return await message.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=reply.menu_shift_open(WEB_APP_URL))

    comment = message.text if message.text != "‚û°Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å" else None
    
    data = await state.get_data()
    shift_id = data.get('current_shift_id')
    
    active = await shift_repo.get_active_shift(message.from_user.id, restaurant_id)
    if not active or active['id'] != shift_id: 
        await state.clear()
        return await message.answer("–°–º–µ–Ω–∞ —É–∂–µ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞.", reply_markup=reply.menu_shift_open(WEB_APP_URL))

    tasks_list = await check_repo.get_checklist(restaurant_id, active['role'], active['shift_type'])
    try:
        data_report = json.loads(active['report']) if active['report'] else {}
        user_duties = data_report.get('duties', [])
    except: user_duties = []
    
    completed_count = 0
    visual = ""
    for i, task in enumerate(tasks_list):
        is_done = False
        if i < len(user_duties):
            is_done = user_duties[i].get('done', False)
        
        if is_done:
            visual += f"‚úÖ {task}\n"
            completed_count += 1
        else:
            visual += f"üü• {task}\n"
    
    total = len(tasks_list)
    percent = int((completed_count / total) * 100) if total > 0 else 0
    
    user = await user_repo.get_user(message.from_user.id, restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    r_name = roles_map.get(active['role'], active['role'])
    
    msg_text = (
        f"üîî <b>–ü–†–û–ú–ï–ñ–£–¢–û–ß–ù–´–ô –û–¢–ß–ï–¢</b>\n"
        f"üë§ <b>–°–æ—Ç—Ä—É–¥–Ω–∏–∫:</b> {user['full_name']} (<b>{r_name}</b>)\n"
        f"üìÖ <b>–°–º–µ–Ω–∞:</b> {active['shift_type']}\n"
        f"üìä <b>–í—ã–ø–æ–ª–Ω–µ–Ω–æ:</b> {completed_count}/{total} ({percent}%)\n"
    )
    if comment:
        msg_text += f"üí¨ <b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</b> {comment}\n"
    
    msg_text += f"\n{visual}"

    for admin_id in await user_repo.get_admins_ids(restaurant_id):
        try:
            await message.bot.send_message(admin_id, msg_text)
        except: pass
    
    await state.clear()
    await message.answer("‚úÖ –û—Ç—á–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω!", reply_markup=reply.menu_shift_open(WEB_APP_URL))


@router.message(F.text == "üî¥ –ó–∞–∫–æ–Ω—á–∏—Ç—å —Å–º–µ–Ω—É")
async def end_shift_ask_comment(message: Message, state: FSMContext, restaurant_id: int):
    if not await shift_repo.get_active_shift(message.from_user.id, restaurant_id): return await message.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π —Å–º–µ–Ω—ã.")
    await state.set_state(ShiftState.waiting_end_comment)
    await message.answer(
        "üìù <b>–ï—Å—Ç—å —á—Ç–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–µ–¥ –∑–∞–∫—Ä—ã—Ç–∏–µ–º?</b>\n–ù–∞–ø–∏—à–∏—Ç–µ –∏—Ç–æ–≥–∏, –ø—Ä–æ–±–ª–µ–º—ã –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ¬´–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å¬ª.",
        reply_markup=reply.comment_menu()
    )

@router.message(ShiftState.waiting_end_comment)
async def end_shift_process_comment(message: Message, state: FSMContext):
    comment = message.text if message.text != "‚û°Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å" else None
    await state.update_data(end_comment=comment)
    
    await state.set_state(ShiftState.waiting_for_photo_end)
    await message.answer("üé• <b>–¢–µ–ø–µ—Ä—å –∑–∞–ø–∏—à–∏—Ç–µ –≤–∏–¥–µ–æ-–∫—Ä—É–∂–æ–∫</b> –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è.", reply_markup=reply.cancel())

@router.message(ShiftState.waiting_for_photo_end, ~F.video_note)
async def end_wrong_media(message: Message):
    await message.answer("‚ùå <b>–û—à–∏–±–∫–∞!</b>\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ <b>–í–ò–î–ï–û-–ö–†–£–ñ–û–ö</b> –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è.")

@router.message(ShiftState.waiting_for_photo_end, F.video_note)
async def end_shift_with_video(message: Message, state: FSMContext, restaurant_id: int):
    tg_id = message.from_user.id
    video_note_id = message.video_note.file_id
    
    data = await state.get_data()
    end_comment = data.get('end_comment')

    active = await shift_repo.get_active_shift(tg_id, restaurant_id)
    if not active:
        await state.clear()
        return await message.answer("–°–º–µ–Ω–∞ —É–∂–µ –∑–∞–∫—Ä—ã—Ç–∞.")
    
    user_info = await user_repo.get_user(tg_id, restaurant_id)
    tasks_list = await check_repo.get_checklist(restaurant_id, active['role'], active['shift_type'])
    
    result = await shift_service.close_shift_logic(tg_id, restaurant_id, active['report'] or "{}", user_info['full_name'], tasks_list, end_comment)
    
    await message.answer(result['user_report'], reply_markup=reply.menu_shift_closed())
    await state.clear()
    
    for admin_id in await user_repo.get_admins_ids(restaurant_id):
        try:
            await message.bot.send_video_note(admin_id, video_note_id)
            await message.bot.send_message(admin_id, result['user_report'])
        except: pass

@router.message(F.text == "üí∞ –ú–æ–π –±–∞–ª–∞–Ω—Å")
async def balance_btn(message: Message, restaurant_id: int):
    balance = await task_repo.get_balance(message.from_user.id, restaurant_id)
    await message.answer(f"üí≥ <b>–í–∞—à –±–æ–Ω—É—Å–Ω—ã–π —Å—á–µ—Ç:</b>\n\nüíé <b>{balance} –±–∞–ª–ª–æ–≤</b>")

@router.message(F.text == "üìú –ò—Å—Ç–æ—Ä–∏—è —Å–º–µ–Ω")
async def history_btn(message: Message, restaurant_id: int):
    shifts = await shift_repo.get_last_shifts(message.from_user.id, restaurant_id)
    if shifts: text = "üóì <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å–º–µ–Ω—ã:</b>\n\n" + "\n".join(f"üîπ {s['started_at']} ({s.get('shift_type', 'full')})" for s in shifts)
    else: text = "üì≠ –ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞."
    await message.answer(text)

==================== FILE: ./app/handlers/__init__.py ====================



==================== FILE: ./app/handlers/admin/staff.py ====================

import json
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.filters import StateFilter

from app.database.repo import users as user_repo, tasks as task_repo, roles as role_repo
from app.database.repo import saas as saas_repo
from app.services import kpi as kpi_service
from app.keyboards import reply, builders
from app.states.states import MoneyState

router = Router()

@router.message(F.text == "üë• –°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏")
async def list_staff(message: Message, restaurant_id: int):
    if await user_repo.get_session_role(message.from_user.id) != "admin": return
    users = await user_repo.get_all_users(restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    await message.answer("üìÇ <b>–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏:</b>", reply_markup=builders.staff_list(users, message.from_user.id, roles_map))

@router.callback_query(F.data.startswith("open_staff:"))
async def open_staff_menu(callback: CallbackQuery, restaurant_id: int):
    tg_id = int(callback.data.split(":")[1])
    user = await user_repo.get_user(tg_id, restaurant_id)
    if not user: return await callback.answer("–°–æ—Ç—Ä—É–¥–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
    
    roles_map = await role_repo.get_roles_map(restaurant_id)
    r_name = roles_map.get(user['role'], user['role'])
    
    await callback.message.edit_text(
        f"üë§ <b>{user['full_name']}</b>\n"
        f"üíº –î–æ–ª–∂–Ω–æ—Å—Ç—å: {r_name}\n"
        f"üíé –ë–∞–ª–∞–Ω—Å: {user['balance']} –±–∞–ª–ª–æ–≤", 
        reply_markup=builders.employee_actions(user['tg_id'], user['full_name'])
    )

@router.callback_query(F.data == "back_to_staff")
async def back_to_staff_list(callback: CallbackQuery, restaurant_id: int):
    users = await user_repo.get_all_users(restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    await callback.message.edit_text("üìÇ <b>–°–æ—Ç—Ä—É–¥–Ω–∏–∫–∏:</b>", reply_markup=builders.staff_list(users, callback.from_user.id, roles_map))

@router.callback_query(F.data.startswith("kpi:"))
async def show_kpi_stats(callback: CallbackQuery, restaurant_id: int):
    tg_id = int(callback.data.split(":")[1])
    user = await user_repo.get_user(tg_id, restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    r_name = roles_map.get(user['role'], user['role'])
    
    stats = await kpi_service.calculate_kpi(tg_id, restaurant_id)
    emoji = "‚úÖ" if stats['is_eligible'] else "‚ö†Ô∏è"
    status_text = "–ë–û–ù–£–° –ü–û–õ–û–ñ–ï–ù" if stats['is_eligible'] else "–ù–ò–ó–ö–û–ï –ö–ê–ß–ï–°–¢–í–û"
    
    text = (
        f"üìä <b>KPI –°–æ—Ç—Ä—É–¥–Ω–∏–∫–∞: {user['full_name']}</b> ({r_name})\n\n"
        f"üìÖ <b>–°–º–µ–Ω (X):</b> {stats['shifts_x']}\n"
        f"‚òëÔ∏è <b>–°—Ä. –∑–∞–¥–∞—á (Y):</b> {stats['tasks_y_avg']}\n"
        f"üöÄ <b>–ö–æ—ç—Ñ. –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:</b> {stats['activity_score']}\n"
        f"üìà <b>–ö–∞—á–µ—Å—Ç–≤–æ:</b> {stats['efficiency_percent']}%\n\n"
        f"{emoji} <b>{status_text}</b>\n"
        f"üí∞ <b>–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:</b> {user['balance']}"
    )
    
    kb = builders.InlineKeyboardBuilder()
    kb.button(text="üí∏ –í—ã–ø–ª–∞—Ç–∏—Ç—å –∏ –æ–±–Ω—É–ª–∏—Ç—å", callback_data=f"pay_bonus:{tg_id}")
    kb.button(text="üîô –ù–∞–∑–∞–¥", callback_data=f"open_staff:{tg_id}")
    kb.adjust(1)
    
    await callback.message.edit_text(text, reply_markup=kb.as_markup())

@router.callback_query(F.data.startswith("pay_bonus:"))
async def pay_bonus_handler(callback: CallbackQuery, restaurant_id: int):
    tg_id = int(callback.data.split(":")[1])
    user = await user_repo.get_user(tg_id, restaurant_id)
    amount = user['balance']
    
    if amount <= 0:
        return await callback.answer("–ë–∞–ª–∞–Ω—Å —É–∂–µ –ø—É—Å—Ç!", show_alert=True)
        
    await task_repo.reset_balance(tg_id, restaurant_id)
    await callback.answer(f"‚úÖ –í—ã–ø–ª–∞—á–µ–Ω–æ {amount} –±–∞–ª–ª–æ–≤!", show_alert=True)
    
    user = await user_repo.get_user(tg_id, restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    r_name = roles_map.get(user['role'], user['role'])
    stats = await kpi_service.calculate_kpi(tg_id, restaurant_id)
    emoji = "‚úÖ" if stats['is_eligible'] else "‚ö†Ô∏è"
    status_text = "–ë–û–ù–£–° –ü–û–õ–û–ñ–ï–ù" if stats['is_eligible'] else "–ù–ò–ó–ö–û–ï –ö–ê–ß–ï–°–¢–í–û"
    
    text = (
        f"üìä <b>KPI –°–æ—Ç—Ä—É–¥–Ω–∏–∫–∞: {user['full_name']}</b> ({r_name})\n\n"
        f"üìÖ <b>–°–º–µ–Ω (X):</b> {stats['shifts_x']}\n"
        f"‚òëÔ∏è <b>–°—Ä. –∑–∞–¥–∞—á (Y):</b> {stats['tasks_y_avg']}\n"
        f"üöÄ <b>–ö–æ—ç—Ñ. –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏:</b> {stats['activity_score']}\n"
        f"üìà <b>–ö–∞—á–µ—Å—Ç–≤–æ:</b> {stats['efficiency_percent']}%\n\n"
        f"{emoji} <b>{status_text}</b>\n"
        f"üí∞ <b>–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å:</b> {user['balance']}" 
    )
    
    kb = builders.InlineKeyboardBuilder()
    kb.button(text="üí∏ –í—ã–ø–ª–∞—Ç–∏—Ç—å –∏ –æ–±–Ω—É–ª–∏—Ç—å", callback_data=f"pay_bonus:{tg_id}")
    kb.button(text="üîô –ù–∞–∑–∞–¥", callback_data=f"open_staff:{tg_id}")
    kb.adjust(1)
    
    await callback.message.edit_text(text, reply_markup=kb.as_markup())
    
    try:
        await callback.bot.send_message(tg_id, f"ü•≥ <b>–í–∞–º –≤—ã–ø–ª–∞—á–µ–Ω –±–æ–Ω—É—Å: {amount} –±–∞–ª–ª–æ–≤!</b>\n–ë–∞–ª–∞–Ω—Å –æ–±–Ω—É–ª–µ–Ω.")
    except: pass

@router.callback_query(F.data.startswith("reset_stats:"))
async def ask_reset_stats(callback: CallbackQuery):
    tg_id = int(callback.data.split(":")[1])
    
    builder = builders.InlineKeyboardBuilder()
    builder.button(text="‚úÖ –î–∞, —Å–±—Ä–æ—Å–∏—Ç—å", callback_data=f"confirm_reset:{tg_id}")
    builder.button(text="üîô –û—Ç–º–µ–Ω–∞", callback_data=f"open_staff:{tg_id}")
    builder.adjust(1)
    
    await callback.message.edit_text(
        "‚ö†Ô∏è <b>–ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π –ø–µ—Ä–∏–æ–¥?</b>\n\n"
        "–≠—Ç–æ –æ–±–Ω—É–ª–∏—Ç —Å—á–µ—Ç—á–∏–∫–∏ —Å–º–µ–Ω –∏ KPI, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –º–µ—Å—è—Ü –∑–∞–Ω–æ–≤–æ.\n"
        "–ë–∞–ª–∞–Ω—Å –¥–µ–Ω–µ–≥ –æ—Å—Ç–∞–Ω–µ—Ç—Å—è.",
        reply_markup=builder.as_markup()
    )

@router.callback_query(F.data.startswith("confirm_reset:"))
async def confirm_reset_stats(callback: CallbackQuery, restaurant_id: int):
    tg_id = int(callback.data.split(":")[1])
    await user_repo.reset_user_kpi_date(tg_id, restaurant_id)
    await callback.answer("‚úÖ –ù–æ–≤—ã–π –ø–µ—Ä–∏–æ–¥ –Ω–∞—á–∞—Ç.", show_alert=True)
    await open_staff_menu(callback, restaurant_id)

@router.callback_query(F.data.startswith("fire:"))
async def ask_fire_staff(callback: CallbackQuery, restaurant_id: int):
    tg_id = int(callback.data.split(":")[1])
    
    restaurant_info = await saas_repo.get_restaurant_info(restaurant_id)
    
    if restaurant_info and restaurant_info['owner_tg_id'] == tg_id:
        return await callback.answer("‚õî –ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å –í–ª–∞–¥–µ–ª—å—Ü–∞ –∫–æ—Ñ–µ–π–Ω–∏!", show_alert=True)
        
    if tg_id == callback.from_user.id:
        return await callback.answer("‚õî –í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —É–¥–∞–ª–∏—Ç—å —Å–∞–º–∏ —Å–µ–±—è. –ü—Ä–æ—Å—Ç–æ –≤—ã–π–¥–∏—Ç–µ –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞.", show_alert=True)

    user = await user_repo.get_user(tg_id, restaurant_id)
    
    builder = builders.InlineKeyboardBuilder()
    builder.button(text="üóë –î–∞, —É–¥–∞–ª–∏—Ç—å", callback_data=f"confirm_fire:{tg_id}")
    builder.button(text="üîô –ù–µ—Ç, –æ—à–∏–±–∫–∞", callback_data=f"open_staff:{tg_id}")
    builder.adjust(1)
    
    await callback.message.edit_text(
        f"‚ö†Ô∏è <b>–í–´ –£–í–ï–†–ï–ù–´?</b>\n\n"
        f"–í—ã —Å–æ–±–∏—Ä–∞–µ—Ç–µ—Å—å —É–¥–∞–ª–∏—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞: <b>{user['full_name']}</b>.\n"
        f"–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ. –£–¥–∞–ª–∏—Ç—Å—è –≤—Å—è –∏—Å—Ç–æ—Ä–∏—è –∏ –±–∞–ª–∞–Ω—Å.",
        reply_markup=builder.as_markup()
    )

@router.callback_query(F.data.startswith("confirm_fire:"))
async def confirm_fire_staff(callback: CallbackQuery, restaurant_id: int):
    tg_id = int(callback.data.split(":")[1])
    await user_repo.fully_delete_user(tg_id, restaurant_id)
    await callback.answer("‚úÖ –°–æ—Ç—Ä—É–¥–Ω–∏–∫ —É–¥–∞–ª–µ–Ω.", show_alert=True)
    await back_to_staff_list(callback, restaurant_id)

@router.callback_query(F.data.startswith("money:"))
async def money_start(callback: CallbackQuery, state: FSMContext):
    tg_id = int(callback.data.split(":")[1])
    await state.update_data(target_id=tg_id)
    
    await state.set_state(MoneyState.waiting_for_amount)
    await callback.message.answer(
        "üí∞ <b>–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –±–∞–ª–ª–æ–≤:</b>\n\n"
        "–ü—Ä–∏–º–µ—Ä: <code>500</code> (–ø—Ä–µ–º–∏—è) –∏–ª–∏ <code>-500</code> (—à—Ç—Ä–∞—Ñ).", 
        reply_markup=reply.cancel()
    )
    await callback.answer()

@router.message(StateFilter(MoneyState), F.text == "‚ùå –û—Ç–º–µ–Ω–∞")
async def cancel_money_state(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=reply.admin_main())

@router.message(MoneyState.waiting_for_amount)
async def money_amount_handler(message: Message, state: FSMContext):
    try:
        amount = int(message.text)
        await state.update_data(amount=amount)
        await state.set_state(MoneyState.waiting_for_reason)
        
        action = "–ü–†–ï–ú–ò–ò" if amount > 0 else "–®–¢–†–ê–§–ê"
        await message.answer(f"‚úçÔ∏è <b>–ù–∞–ø–∏—à–∏—Ç–µ –ø—Ä–∏—á–∏–Ω—É {action}:</b>")
    except ValueError:
        await message.answer("‚ùå –ù—É–∂–Ω–æ –≤–≤–µ—Å—Ç–∏ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 100). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")

@router.message(MoneyState.waiting_for_reason)
async def money_reason_handler(message: Message, state: FSMContext, restaurant_id: int):
    data = await state.get_data()
    target_id = data['target_id']
    amount = data['amount']
    reason = message.text
    
    await task_repo.add_bonus(target_id, restaurant_id, amount)
    user = await user_repo.get_user(target_id, restaurant_id)
    
    await message.answer(
        f"‚úÖ <b>–ë–∞–ª–∞–Ω—Å –∏–∑–º–µ–Ω–µ–Ω!</b>\n"
        f"üë§ –°–æ—Ç—Ä—É–¥–Ω–∏–∫: {user['full_name']}\n"
        f"üí∞ –°—É–º–º–∞: {amount:+}\n"
        f"üìù –ü—Ä–∏—á–∏–Ω–∞: {reason}\n"
        f"üíé –ò—Ç–æ–≥: {user['balance']}",
        reply_markup=reply.admin_main()
    )
    
    emoji = "üéÅ" if amount > 0 else "üìâ"
    try:
        await message.bot.send_message(
            target_id,
            f"{emoji} <b>–ò–ó–ú–ï–ù–ï–ù–ò–ï –ë–ê–õ–ê–ù–°–ê: {amount:+}</b>\n"
            f"üìù –ü—Ä–∏—á–∏–Ω–∞: {reason}\n"
            f"üí≥ –í–∞—à –±–∞–ª–∞–Ω—Å: {user['balance']}"
        )
    except: pass
    
    await state.clear()

==================== FILE: ./app/handlers/admin/invites.py ====================

from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery
from aiogram.utils.keyboard import InlineKeyboardBuilder
from app.database.repo import users as user_repo, roles as role_repo, checklists as check_repo
from app.keyboards import builders

router = Router()

@router.message(F.text.in_({"üîó –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è", "üîó –°–æ–∑–¥–∞—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ"}))
async def invite_start(message: Message, restaurant_id: int):
    if await user_repo.get_session_role(message.from_user.id) != "admin": return
    roles = await role_repo.get_all_roles(restaurant_id)
    await message.answer(
        "üìù <b>–î–ª—è –∫–∞–∫–æ–π —Ä–æ–ª–∏ —Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É?</b>", 
        reply_markup=builders.dynamic_role_select(roles, "create_invite", show_admin=True)
    )

@router.callback_query(F.data.startswith("create_invite:"))
async def create_invite_link(callback: CallbackQuery, bot: Bot, restaurant_id: int):
    role_slug = callback.data.split(":")[1]
    role_info = await role_repo.get_role(restaurant_id, role_slug)
    role_name = role_info['name'] if role_info else ("–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä" if role_slug == "admin" else role_slug)
    
    code = await check_repo.create_invite(restaurant_id, role_slug)
    bot_info = await bot.get_me()
    link = f"https://t.me/{bot_info.username}?start={code}"
    
    text = (
        f"‚úÖ <b>–°—Å—ã–ª–∫–∞ —Å–æ–∑–¥–∞–Ω–∞!</b>\n\n"
        f"–†–æ–ª—å: <b>{role_name}</b>\n"
        f"–°—Å—ã–ª–∫–∞: <code>{link}</code>\n\n"
        f"<i>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—ë —Å–æ—Ç—Ä—É–¥–Ω–∏–∫—É. –û–Ω–∞ –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–∞—è.</i>"
    )
    
    kb = InlineKeyboardBuilder()
    kb.button(text="üîô –ù–∞–∑–∞–¥", callback_data="back_to_admin")
    await callback.message.edit_text(text, reply_markup=kb.as_markup())

==================== FILE: ./app/handlers/admin/tasks.py ====================

import aiosqlite
from datetime import datetime, timedelta
from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.context import FSMContext
from aiogram.filters import StateFilter
from aiogram.exceptions import TelegramBadRequest

from app.core.config import TZ, DB_PATH
from app.database.repo import users as user_repo, tasks as task_repo, shifts as shift_repo, roles as role_repo
from app.keyboards import builders, reply
from app.states.states import TaskState
from app.services import tasks as task_service

router = Router()

@router.callback_query(F.data.startswith("done_task:"))
async def complete_task_handler(callback: CallbackQuery, restaurant_id: int):
    try:
        task_id = int(callback.data.split(":")[1])
        reward, text = await task_service.try_complete_task(task_id, restaurant_id)
        
        if reward > 0:
            await callback.message.edit_text(f"‚úÖ <b>–í–´–ü–û–õ–ù–ï–ù–û!</b>\nüí∞ –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ: +{reward} –±–∞–ª–ª–æ–≤")
            user = await user_repo.get_user(callback.from_user.id, restaurant_id)
            admin_msg = f"üîî <b>–ó–ê–î–ê–ß–ê –í–´–ü–û–õ–ù–ï–ù–ê!</b>\nüë§ {user['full_name']}\nüìù {text}\nüí∞ +{reward}"
            for admin_id in await user_repo.get_admins_ids(restaurant_id):
                try: await callback.bot.send_message(admin_id, admin_msg)
                except: pass
        elif reward == -1:
            await callback.message.edit_text(f"‚è≥ <b>–í–†–ï–ú–Ø –ò–°–¢–ï–ö–õ–û!</b>\n–í—ã –Ω–µ —É—Å–ø–µ–ª–∏ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–¥–∞—á—É –≤–æ–≤—Ä–µ–º—è.")
        else:
            await callback.answer("–≠—Ç–∞ –∑–∞–¥–∞—á–∞ —É–∂–µ –Ω–µ–∞–∫—Ç—É–∞–ª—å–Ω–∞.", show_alert=True)
            await callback.message.delete()
    except Exception as e:
        await callback.answer(f"–û—à–∏–±–∫–∞: {e}", show_alert=True)

@router.message(F.text == "üìù –ó–∞–¥–∞–Ω–∏—è")
async def tasks_main_menu(message: Message):
    if await user_repo.get_session_role(message.from_user.id) != "admin": return
    kb = reply.ReplyKeyboardMarkup(
        keyboard=[
            [reply.KeyboardButton(text="üìù –î–∞—Ç—å –∑–∞–¥–∞–Ω–∏–µ"), reply.KeyboardButton(text="üóë –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ")],
            [reply.KeyboardButton(text="üìú –ò—Å—Ç–æ—Ä–∏—è –∑–∞–¥–∞–Ω–∏–π")],
            [reply.KeyboardButton(text="üîô –í –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")]
        ],
        resize_keyboard=True
    )
    await message.answer("üìù <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞–Ω–∏—è–º–∏:</b>", reply_markup=kb)

@router.message(F.text == "üìú –ò—Å—Ç–æ—Ä–∏—è –∑–∞–¥–∞–Ω–∏–π")
async def tasks_history(message: Message, restaurant_id: int):
    if await user_repo.get_session_role(message.from_user.id) != "admin": return
    
    history = await task_repo.get_tasks_history(restaurant_id, limit=10)
    if not history:
        return await message.answer("üì≠ –ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞.")
        
    text = "üìú <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 –∑–∞–¥–∞–Ω–∏–π:</b>\n\n"
    for t in history:
        status_icon = {"completed": "‚úÖ", "expired": "‚è≥", "canceled": "üö´", "pending": "üïí"}.get(t['status'], "‚ùì")
        text += f"{status_icon} <b>{t['full_name']}</b>: {t['text']} ({t['reward']})\n"
        
    await message.answer(text)

@router.message(F.text == "üìù –î–∞—Ç—å –∑–∞–¥–∞–Ω–∏–µ")
async def start_task(message: Message, state: FSMContext):
    if await user_repo.get_session_role(message.from_user.id) != "admin": return
    await state.set_state(TaskState.waiting_text)
    await message.answer("‚úçÔ∏è –¢–µ–∫—Å—Ç –∑–∞–¥–∞–Ω–∏—è:", reply_markup=reply.cancel())

@router.message(StateFilter(TaskState), F.text == "‚ùå –û—Ç–º–µ–Ω–∞")
async def cancel_task_creation(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=reply.admin_main())

@router.message(TaskState.waiting_text)
async def task_text(message: Message, state: FSMContext):
    await state.update_data(text=message.text)
    await state.set_state(TaskState.waiting_reward)
    await message.answer("üí∞ –ù–∞–≥—Ä–∞–¥–∞ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ):")

@router.message(TaskState.waiting_reward)
async def task_reward(message: Message, state: FSMContext):
    if not message.text.isdigit(): return await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ!")
    await state.update_data(reward=int(message.text))
    await state.set_state(TaskState.waiting_hours) 
    await message.answer("‚è≥ –°—Ä–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è (–º–∏–Ω—É—Ç—ã, –Ω–∞–ø—Ä–∏–º–µ—Ä 30, –∏–ª–∏ —á–∞—Å—ã '1—á'):")

@router.message(TaskState.waiting_hours)
async def task_deadline_parse(message: Message, state: FSMContext, restaurant_id: int):
    raw = message.text.lower().strip()
    try:
        if '—á' in raw or 'h' in raw:
            mins = int(float(raw.replace('—á','').replace('h','')) * 60)
        else:
            mins = int(raw)
        if mins <= 0: raise ValueError
    except: return await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ü–∏—à–∏—Ç–µ –º–∏–Ω—É—Ç—ã (30) –∏–ª–∏ —á–∞—Å—ã (1—á).")
    
    deadline = (datetime.now(TZ) + timedelta(minutes=mins)).strftime("%Y-%m-%d %H:%M:%S")
    await state.update_data(deadline=deadline, time_display=message.text)
    
    active_shifts = await shift_repo.get_all_active_shifts_data(restaurant_id)
    if not active_shifts:
        await state.clear()
        return await message.answer("‚ùå <b>–û—à–∏–±–∫–∞:</b> –°–µ–π—á–∞—Å –Ω–µ—Ç –Ω–∏–∫–æ–≥–æ –Ω–∞ —Å–º–µ–Ω–µ.", reply_markup=reply.admin_main())

    active_ids = [s['user_id'] for s in active_shifts]
    users = await user_repo.get_all_users(restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    
    await state.set_state(TaskState.waiting_employee)
    await message.answer("üëâ –ö–æ–º—É –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ?", reply_markup=builders.task_assign_menu(users, message.from_user.id, active_ids, roles_map))

@router.callback_query(TaskState.waiting_employee, F.data.startswith("assign:"))
async def task_finish(callback: CallbackQuery, state: FSMContext, bot: Bot, restaurant_id: int):
    target_id = int(callback.data.split(":")[1])
    active = await shift_repo.get_active_shift(target_id, restaurant_id)
    if not active:
        await callback.answer("‚õî –û–®–ò–ë–ö–ê: –°–æ—Ç—Ä—É–¥–Ω–∏–∫ —É–∂–µ –∑–∞–∫—Ä—ã–ª —Å–º–µ–Ω—É!", show_alert=True)
        return

    data = await state.get_data()
    tid = await task_repo.create_personal_task_with_deadline(data['text'], data['reward'], data['deadline'], target_id, restaurant_id)
    
    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text="‚úÖ –Ø –≤—ã–ø–æ–ª–Ω–∏–ª!", callback_data=f"done_task:{tid}")]])
    
    try:
        msg_text = (
            f"‚ö°Ô∏è <b>–ù–û–í–û–ï –ó–ê–î–ê–ù–ò–ï!</b>\n\n"
            f"üìù {data['text']}\n"
            f"‚è≥ –°—Ä–æ–∫: {data['time_display']}\n"
            f"üí∞ –ù–∞–≥—Ä–∞–¥–∞: +{data['reward']} –±–∞–ª–ª–æ–≤"
        )
        sent_msg = await bot.send_message(target_id, msg_text, reply_markup=kb)
        await task_repo.set_task_message_id(tid, sent_msg.message_id)
        
        await callback.message.delete()
        await callback.message.answer("‚úÖ –ó–∞–¥–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ.", reply_markup=reply.admin_main())
    except:
        await callback.message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å (–≤–æ–∑–º–æ–∂–Ω–æ –±–æ—Ç –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω).")
    
    await state.clear()

@router.message(F.text == "üóë –û—Ç–º–µ–Ω–∏—Ç—å –∑–∞–¥–∞–Ω–∏–µ")
async def cancel_task_menu(message: Message, restaurant_id: int):
    if await user_repo.get_session_role(message.from_user.id) != "admin": return
    tasks = await task_repo.get_pending_tasks_details(restaurant_id)
    if not tasks: return await message.answer("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞–Ω–∏–π.")

    b = builders.InlineKeyboardBuilder()
    for t in tasks:
        b.button(text=f"‚ùå {t['text'][:20]}... ({t['full_name']})", callback_data=f"admin_cancel:{t['id']}")
    b.button(text="üîô –ù–∞–∑–∞–¥", callback_data="back_to_admin")
    b.adjust(1)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞–Ω–∏–µ –¥–ª—è –æ—Ç–º–µ–Ω—ã:", reply_markup=b.as_markup())

@router.callback_query(F.data.startswith("admin_cancel:"))
async def admin_cancel(callback: CallbackQuery, bot: Bot, restaurant_id: int):
    tid = int(callback.data.split(":")[1])
    task = await task_repo.get_task_details(tid, restaurant_id)
    await task_repo.cancel_task_in_db(tid, restaurant_id)
    
    if task and task['message_id']:
        try:
            await bot.edit_message_text(
                chat_id=task['assigned_to'],
                message_id=task['message_id'],
                text=f"üö´ <b>–ó–ê–î–ê–ß–ê –û–¢–ú–ï–ù–ï–ù–ê –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†–û–ú</b>\nüìù {task['text']}",
                reply_markup=None
            )
        except: pass

    tasks = await task_repo.get_pending_tasks_details(restaurant_id)
    if not tasks:
        await callback.message.edit_text("üéâ –í—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–¥–∞–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω—ã (—Å–ø–∏—Å–æ–∫ –ø—É—Å—Ç).")
    else:
        b = builders.InlineKeyboardBuilder()
        for t in tasks:
            b.button(text=f"‚ùå {t['text'][:20]}... ({t['full_name']})", callback_data=f"admin_cancel:{t['id']}")
        b.button(text="üîô –ù–∞–∑–∞–¥", callback_data="back_to_admin")
        b.adjust(1)
        try:
            await callback.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–¥–∞–Ω–∏–µ –¥–ª—è –æ—Ç–º–µ–Ω—ã:", reply_markup=b.as_markup())
        except TelegramBadRequest:
            pass
    await callback.answer("–ó–∞–¥–∞–Ω–∏–µ –∞–Ω–Ω—É–ª–∏—Ä–æ–≤–∞–Ω–æ.")

==================== FILE: ./app/handlers/admin/roles.py ====================

import uuid
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.filters import StateFilter
from app.database.repo import users as user_repo, roles as role_repo
from app.keyboards import reply, builders
from app.states.states import RoleState

router = Router()

@router.message(StateFilter("*"), F.text == "üîô –í –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")
async def back_main(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=reply.admin_main())

@router.callback_query(StateFilter("*"), F.data == "back_to_admin")
async def back_admin_inline(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.delete()
    await callback.message.answer("–ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è", reply_markup=reply.admin_main())

@router.message(StateFilter("*"), F.text == "üé≠ –†–æ–ª–∏")
async def roles_menu(message: Message, state: FSMContext, restaurant_id: int):
    await state.clear()
    if await user_repo.get_session_role(message.from_user.id) != "admin": return
    await message.answer("üé≠ <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–æ–ª—è–º–∏:</b>", reply_markup=reply.admin_roles_menu())

@router.message(StateFilter("*"), F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å —Ä–æ–ª—å")
async def add_role_start(message: Message, state: FSMContext):
    await state.clear()
    await state.set_state(RoleState.waiting_role_name)
    await message.answer("‚úçÔ∏è –ù–∞–∑–≤–∞–Ω–∏–µ —Ä–æ–ª–∏ (–Ω–∞ —Ä—É—Å—Å–∫–æ–º):", reply_markup=reply.cancel())

@router.message(RoleState.waiting_role_name)
async def add_role_finish(message: Message, state: FSMContext, restaurant_id: int):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞": return await back_main(message, state)
    slug = f"role_{uuid.uuid4().hex[:6]}"
    await role_repo.add_role(restaurant_id, slug, message.text.strip())
    await state.clear()
    await message.answer(f"‚úÖ –†–æ–ª—å –¥–æ–±–∞–≤–ª–µ–Ω–∞!", reply_markup=reply.admin_roles_menu())

@router.message(StateFilter("*"), F.text == "üìù –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–æ–ª—å")
async def edit_role_list(message: Message, state: FSMContext, restaurant_id: int):
    await state.clear()
    roles = await role_repo.get_all_roles(restaurant_id)
    await message.answer("–ö–∞–∫—É—é –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å?", reply_markup=builders.dynamic_role_select(roles, "edit_role_name"))

@router.callback_query(F.data.startswith("edit_role_name:"))
async def edit_role_name_start(callback: CallbackQuery, state: FSMContext, restaurant_id: int):
    slug = callback.data.split(":")[1]
    role = await role_repo.get_role(restaurant_id, slug)
    await state.update_data(slug=slug)
    await state.set_state(RoleState.waiting_new_role_name)
    await callback.message.edit_text(f"‚úçÔ∏è –ù–æ–≤–æ–µ –∏–º—è –¥–ª—è <b>{role['name']}</b>:", reply_markup=None)

@router.message(RoleState.waiting_new_role_name)
async def edit_role_name_finish(message: Message, state: FSMContext, restaurant_id: int):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞": return await back_main(message, state)
    data = await state.get_data()
    await role_repo.update_role_name(restaurant_id, data['slug'], message.text.strip())
    await state.clear()
    await message.answer("‚úÖ –ò–∑–º–µ–Ω–µ–Ω–æ.", reply_markup=reply.admin_roles_menu())

@router.message(StateFilter("*"), F.text == "‚ùå –£–¥–∞–ª–∏—Ç—å —Ä–æ–ª—å")
async def del_role_start(message: Message, state: FSMContext, restaurant_id: int):
    await state.clear()
    roles = await role_repo.get_all_roles(restaurant_id)
    await message.answer("–ö–∞–∫—É—é —Ä–æ–ª—å —É–¥–∞–ª–∏—Ç—å?", reply_markup=builders.delete_role_select(roles))

@router.callback_query(F.data.startswith("del_role_db:"))
async def ask_delete_role(callback: CallbackQuery, restaurant_id: int):
    slug = callback.data.split(":")[1]
    role = await role_repo.get_role(restaurant_id, slug)
    
    role_name = role['name'] if role else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
    
    await callback.message.edit_text(
        f"‚ö†Ô∏è <b>–í–´ –£–í–ï–†–ï–ù–´?</b>\n\n"
        f"–í—ã —Ö–æ—Ç–∏—Ç–µ —É–¥–∞–ª–∏—Ç—å —Ä–æ–ª—å: <b>{role_name}</b>.\n"
        f"–ï—Å–ª–∏ –µ—Å—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∏ —Å —ç—Ç–æ–π —Ä–æ–ª—å—é, —É –Ω–∏—Ö –º–æ–≥—É—Ç –≤–æ–∑–Ω–∏–∫–Ω—É—Ç—å –ø—Ä–æ–±–ª–µ–º—ã.",
        reply_markup=builders.confirm_delete_role_menu(slug)
    )

@router.callback_query(F.data == "cancel_del_role")
async def cancel_delete_role(callback: CallbackQuery, restaurant_id: int):
    roles = await role_repo.get_all_roles(restaurant_id)
    await callback.message.edit_text("–ö–∞–∫—É—é —Ä–æ–ª—å —É–¥–∞–ª–∏—Ç—å?", reply_markup=builders.delete_role_select(roles))

@router.callback_query(F.data.startswith("confirm_del_role:"))
async def confirm_delete_role(callback: CallbackQuery, restaurant_id: int):
    slug = callback.data.split(":")[1]
    
    await role_repo.delete_role(restaurant_id, slug)
    
    roles = await role_repo.get_all_roles(restaurant_id)
    if not roles:
        await callback.message.edit_text("–°–ø–∏—Å–æ–∫ —Ä–æ–ª–µ–π –ø—É—Å—Ç (–∫—Ä–æ–º–µ –ê–¥–º–∏–Ω–∞).")
    else:
        await callback.message.edit_text("‚úÖ –†–æ–ª—å —É–¥–∞–ª–µ–Ω–∞.\n–ö–∞–∫—É—é —Ä–æ–ª—å —É–¥–∞–ª–∏—Ç—å?", reply_markup=builders.delete_role_select(roles))
    
    await callback.answer("–†–æ–ª—å —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞")

==================== FILE: ./app/handlers/admin/monitoring.py ====================

import json
from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.exceptions import TelegramBadRequest
from app.database.repo import users as user_repo, shifts as shift_repo, checklists as check_repo, roles as role_repo
from app.keyboards import builders

router = Router()

@router.message(F.text == "üëÄ –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥")
async def monitor_menu(message: Message, restaurant_id: int):
    if await user_repo.get_session_role(message.from_user.id) != "admin": return
    shifts = await shift_repo.get_all_active_shifts_data(restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    
    if not shifts: return await message.answer("ü§∑‚Äç‚ôÇÔ∏è –°–µ–π—á–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–º–µ–Ω.")
    
    await message.answer("üîé <b>–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞:</b>", reply_markup=builders.active_shifts_menu(shifts, roles_map))

@router.callback_query(F.data == "refresh_monitor")
async def refresh_monitor_list(callback: CallbackQuery, restaurant_id: int):
    shifts = await shift_repo.get_all_active_shifts_data(restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    
    try:
        if not shifts: 
            await callback.message.edit_text("ü§∑‚Äç‚ôÇÔ∏è –í—Å–µ —Å–º–µ–Ω—ã –∑–∞–∫—Ä—ã—Ç—ã.", reply_markup=None)
        else:
            await callback.message.edit_text("üîé <b>–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞:</b>", reply_markup=builders.active_shifts_menu(shifts, roles_map))
    except TelegramBadRequest:
        await callback.answer("–î–∞–Ω–Ω—ã–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å")

@router.callback_query(F.data.startswith("monitor:"))
async def monitor_specific_user(callback: CallbackQuery, restaurant_id: int):
    target_id = int(callback.data.split(":")[1])
    active = await shift_repo.get_active_shift(target_id, restaurant_id)
    if not active:
        await callback.answer("–°–º–µ–Ω–∞ —É–∂–µ –∑–∞–∫—Ä—ã—Ç–∞!", show_alert=True)
        return await refresh_monitor_list(callback, restaurant_id)
    
    user = await user_repo.get_user(target_id, restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    r_name = roles_map.get(active['role'], active['role'])
    
    tasks = await check_repo.get_checklist(restaurant_id, active['role'], active['shift_type'])
    
    try:
        data = json.loads(active['report']) if active['report'] else {}
        user_duties = data.get('duties', [])
    except: 
        user_duties = []
    
    visual = ""
    completed_count = 0
    
    for i, task_title in enumerate(tasks):
        is_done = False
        if i < len(user_duties):
            is_done = user_duties[i].get('done', False)
        
        if is_done:
            visual += f"‚úÖ {task_title}\n"
            completed_count += 1
        else:
            visual += f"üü• {task_title}\n"
    
    total = len(tasks)
    perc = int((completed_count / total) * 100) if total > 0 else 0
    
    blocks = perc // 10
    progress = "üü©" * blocks + "‚¨úÔ∏è" * (10 - blocks)
    
    text = (
        f"üë§ <b>{user['full_name']}</b> (<b>{r_name}</b>)\n"
        f"üìä –ü—Ä–æ–≥—Ä–µ—Å—Å: {completed_count}/{total} ({perc}%)\n"
        f"{progress}\n\n"
        f"{visual}\n"
        f"üëá <i>–ù–∞–∂–º–∏—Ç–µ ¬´–û–±–Ω–æ–≤–∏—Ç—å¬ª, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è</i>"
    )
    
    try:
        await callback.message.edit_text(text, reply_markup=builders.back_to_monitor())
    except TelegramBadRequest:
        await callback.answer("–ù–∏—á–µ–≥–æ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å")

@router.callback_query(F.data == "close_checklist")
async def close_check(c: CallbackQuery): 
    await c.message.delete()

==================== FILE: ./app/handlers/admin/__init__.py ====================

from aiogram import Router
from . import checklists, monitoring, reminders, roles, staff, tasks, invites

router = Router()

router.include_routers(
    checklists.router,
    monitoring.router,
    reminders.router,
    roles.router,
    staff.router,
    tasks.router,
    invites.router
)

==================== FILE: ./app/handlers/admin/reminders.py ====================

from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.exceptions import TelegramBadRequest

from app.database.repo import users as user_repo, checklists as check_repo, roles as role_repo
from app.keyboards import builders, reply
from app.states.states import ReminderState

router = Router()

@router.message(F.text == "üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è")
async def reminders_menu(message: Message, restaurant_id: int):
    if await user_repo.get_session_role(message.from_user.id) != "admin": return
    
    reminders = await check_repo.get_all_reminders(restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    
    if not reminders:
        return await message.answer("üîî <b>–°–ø–∏—Å–æ–∫ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –ø—É—Å—Ç.</b>", reply_markup=builders.reminders_list_menu([], roles_map))

    text = "üîî <b>–ê–∫—Ç–∏–≤–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è:</b>\n"
    for r in reminders:
        r_name = roles_map.get(r['role'], r['role'])
        text += f"‚Ä¢ <b>{r_name}</b>: {r['text']} (–∫–∞–∂–¥—ã–µ {r['interval_hours']} –º–∏–Ω)\n"
        
    await message.answer(text, reply_markup=builders.reminders_list_menu(reminders, roles_map))

@router.callback_query(F.data == "add_reminder_start")
async def add_remind_start(callback: CallbackQuery, state: FSMContext, restaurant_id: int):
    await state.set_state(ReminderState.remind_role)
    roles = await role_repo.get_all_roles(restaurant_id)
    await callback.message.edit_text("–î–ª—è –∫–∞–∫–æ–π —Ä–æ–ª–∏ —Å–æ–∑–¥–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ?", reply_markup=builders.dynamic_role_select(roles, "remind_role"))

@router.callback_query(F.data.startswith("remind_role:"))
async def add_remind_role(callback: CallbackQuery, state: FSMContext):
    await state.update_data(role=callback.data.split(":")[1])
    await state.set_state(ReminderState.remind_text)
    await callback.message.edit_text("‚úçÔ∏è –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è:")

@router.message(ReminderState.remind_text)
async def add_remind_text(message: Message, state: FSMContext):
    await state.update_data(text=message.text)
    await state.set_state(ReminderState.remind_interval)
    await message.answer("‚è± –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è –≤ <b>–º–∏–Ω—É—Ç–∞—Ö</b> (–Ω–∞–ø—Ä–∏–º–µ—Ä, 60 –¥–ª—è —á–∞—Å–∞):")

@router.message(ReminderState.remind_interval)
async def add_remind_finish(message: Message, state: FSMContext, restaurant_id: int):
    if not message.text.isdigit(): return await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Ç!")
    data = await state.get_data()
    await check_repo.add_reminder(restaurant_id, data['role'], data['text'], int(message.text))
    await state.clear()
    await message.answer("‚úÖ –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ.", reply_markup=reply.admin_main())

@router.callback_query(F.data.startswith("del_remind:"))
async def delete_remind(callback: CallbackQuery, restaurant_id: int):
    rem_id = int(callback.data.split(":")[1])
    await check_repo.delete_reminder(rem_id, restaurant_id)
    
    reminders = await check_repo.get_all_reminders(restaurant_id)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    
    if not reminders:
        text = "üîî <b>–°–ø–∏—Å–æ–∫ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –ø—É—Å—Ç.</b>"
    else:
        text = "üîî <b>–ê–∫—Ç–∏–≤–Ω—ã–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è:</b>\n"
        for r in reminders:
            r_name = roles_map.get(r['role'], r['role'])
            text += f"‚Ä¢ <b>{r_name}</b>: {r['text']} (–∫–∞–∂–¥—ã–µ {r['interval_hours']} –º–∏–Ω)\n"
    
    try:
        await callback.message.edit_text(text, reply_markup=builders.reminders_list_menu(reminders, roles_map))
    except TelegramBadRequest:
        await callback.answer("–£–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ")
    
    await callback.answer("–£–¥–∞–ª–µ–Ω–æ.")

==================== FILE: ./app/handlers/admin/checklists.py ====================

from aiogram import Router, F
from aiogram.types import Message, CallbackQuery
from aiogram.fsm.context import FSMContext
from aiogram.filters import StateFilter

from app.database.repo import users as user_repo, checklists as check_repo, roles as role_repo
from app.keyboards import reply, builders
from app.states.states import ChecklistState

router = Router()

@router.message(F.text.in_({"‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", "‚öôÔ∏è –ß–µ–∫-–ª–∏—Å—Ç—ã"}))
async def settings_menu(message: Message, restaurant_id: int):
    if await user_repo.get_session_role(message.from_user.id) != "admin": return
    roles = await role_repo.get_all_roles(restaurant_id)
    await message.answer("üìù <b>–†–µ–¥–∞–∫—Ç–æ—Ä —á–µ–∫-–ª–∏—Å—Ç–æ–≤. –í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:</b>", reply_markup=builders.dynamic_role_select(roles, "edit_cl"))

@router.callback_query(F.data == "settings_checklists")
async def back_to_roles_cl(callback: CallbackQuery, restaurant_id: int):
    roles = await role_repo.get_all_roles(restaurant_id)
    await callback.message.edit_text("üìù <b>–í—ã–±–µ—Ä–∏—Ç–µ —Ä–æ–ª—å:</b>", reply_markup=builders.dynamic_role_select(roles, "edit_cl"))

@router.callback_query(F.data.startswith("edit_cl:"))
async def view_checklist_categories(callback: CallbackQuery, restaurant_id: int):
    role_slug = callback.data.split(":")[1]
    roles_map = await role_repo.get_roles_map(restaurant_id)
    role_name = roles_map.get(role_slug, role_slug)
    
    await callback.message.edit_text(
        f"üìÇ <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∞: {role_name}</b>\n"
        f"–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:",
        reply_markup=builders.checklist_categories(role_slug)
    )

@router.callback_query(F.data.startswith("open_cat:"))
async def view_checklist_items(callback: CallbackQuery, state: FSMContext, restaurant_id: int):
    await state.update_data(selected_ids=[], current_page=0)
    parts = callback.data.split(":")
    role_slug = parts[1]
    shift_type = parts[2]
    await render_checklist_items(callback, restaurant_id, role_slug, shift_type, mode="view")

@router.callback_query(F.data.startswith("mode_del:"))
async def enable_delete_mode(callback: CallbackQuery, state: FSMContext, restaurant_id: int):
    parts = callback.data.split(":")
    role_slug = parts[1]
    shift_type = parts[2]
    await state.update_data(selected_ids=[], current_page=0)
    await render_checklist_items(callback, restaurant_id, role_slug, shift_type, mode="delete", state=state)

@router.callback_query(F.data.startswith("cl_page:"))
async def change_page(callback: CallbackQuery, state: FSMContext, restaurant_id: int):
    parts = callback.data.split(":")
    new_page = int(parts[1])
    role_slug = parts[2]
    shift_type = parts[3]
    
    await state.update_data(current_page=new_page)
    await render_checklist_items(callback, restaurant_id, role_slug, shift_type, mode="delete", state=state)

@router.callback_query(F.data.startswith("toggle_sel:"))
async def toggle_selection(callback: CallbackQuery, state: FSMContext, restaurant_id: int):
    parts = callback.data.split(":")
    item_id = int(parts[1])
    role_slug = parts[2]
    shift_type = parts[3]
    
    data = await state.get_data()
    selected = data.get("selected_ids", [])
    
    if item_id in selected:
        selected.remove(item_id)
    else:
        selected.append(item_id)
        
    await state.update_data(selected_ids=selected)
    await render_checklist_items(callback, restaurant_id, role_slug, shift_type, mode="delete", state=state)

@router.callback_query(F.data.startswith("confirm_del:"))
async def confirm_delete_selected(callback: CallbackQuery, state: FSMContext, restaurant_id: int):
    parts = callback.data.split(":")
    role_slug = parts[1]
    shift_type = parts[2]
    
    data = await state.get_data()
    selected = data.get("selected_ids", [])
    
    if selected:
        for item_id in selected:
            await check_repo.delete_checklist_item(item_id, restaurant_id)
        await callback.answer(f"üóë –£–¥–∞–ª–µ–Ω–æ –∑–∞–¥–∞—á: {len(selected)}")
    
    await state.update_data(selected_ids=[], current_page=0)
    await render_checklist_items(callback, restaurant_id, role_slug, shift_type, mode="view")

@router.callback_query(F.data == "noop")
async def noop_handler(callback: CallbackQuery):
    await callback.answer()

async def render_checklist_items(callback: CallbackQuery, restaurant_id: int, role_slug: str, shift_type: str, mode: str, state: FSMContext = None):
    items = await check_repo.get_items_by_type(restaurant_id, role_slug, shift_type)
    roles_map = await role_repo.get_roles_map(restaurant_id)
    role_name = roles_map.get(role_slug, role_slug)
    
    types_rus = {"morning": "–£–¢–†–û üåÖ", "common": "–û–ë–©–ï–ï üîÑ", "evening": "–í–ï–ß–ï–† üåá"}
    type_name = types_rus.get(shift_type, shift_type)
    
    if mode == "delete" and state:
        text = (
            f"üóë <b>–£–î–ê–õ–ï–ù–ò–ï –ó–ê–î–ê–ß</b>\n"
            f"–†–æ–ª—å: <b>{role_name}</b> ({type_name})\n\n"
            f"üëá <i>–û—Ç–º–µ—á–∞–π—Ç–µ –∑–∞–¥–∞—á–∏ –≥–∞–ª–æ—á–∫–∞–º–∏, –∑–∞—Ç–µ–º –Ω–∞–∂–º–∏—Ç–µ ¬´–£–¥–∞–ª–∏—Ç—å¬ª.</i>"
        )
    else:
        text_lines = [f"üìù <b>{role_name} ‚Äî {type_name}</b>\n"]
        if not items:
            text_lines.append("<i>–°–ø–∏—Å–æ–∫ –ø—É—Å—Ç.</i>")
        else:
            for i, it in enumerate(items, 1):
                text_lines.append(f"<b>{i}.</b> {it['text']}")
        text_lines.append("\n‚úÖ <i>–≠—Ç–æ —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á. –ù–∞–∂–º–∏—Ç–µ ¬´–î–æ–±–∞–≤–∏—Ç—å¬ª –∏–ª–∏ ¬´–£–¥–∞–ª–∏—Ç—å¬ª.</i>")
        text = "\n".join(text_lines)

    selected_ids = []
    current_page = 0
    if state:
        data = await state.get_data()
        selected_ids = data.get("selected_ids", [])
        current_page = data.get("current_page", 0)

    try:
        await callback.message.edit_text(
            text,
            reply_markup=builders.checklist_items_edit(items, role_slug, shift_type, mode=mode, selected_ids=selected_ids, page=current_page)
        )
    except:
        await callback.answer()

@router.callback_query(F.data.startswith("add_item:"))
async def add_item_start(callback: CallbackQuery, state: FSMContext):
    parts = callback.data.split(":")
    role = parts[1]
    stype = parts[2]
    
    await state.update_data(role=role, shift_type=stype)
    await state.set_state(ChecklistState.waiting_checklist_text)
    
    data = await state.get_data() 
    
    await callback.message.delete()
    await callback.message.answer(
        f"‚úçÔ∏è –í–≤–µ–¥–∏—Ç–µ –∑–∞–¥–∞—á—É –¥–ª—è —ç—Ç–æ–π —Ä–æ–ª–∏:", 
        reply_markup=reply.cancel()
    )

@router.message(ChecklistState.waiting_checklist_text)
async def add_item_finish(message: Message, state: FSMContext, restaurant_id: int):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await state.clear()
        await message.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=reply.admin_main())
        return

    data = await state.get_data()
    role = data['role']
    shift_type = data['shift_type']
    text = message.text.strip()
    
    if await check_repo.is_checklist_item_exists(restaurant_id, role, shift_type, text):
        await message.answer(f"‚õî <b>–û—à–∏–±–∫–∞!</b>\n–ó–∞–¥–∞—á–∞ ¬´{text}¬ª —É–∂–µ –µ—Å—Ç—å.")
    else:
        await check_repo.add_checklist_item(restaurant_id, role, shift_type, text)
        await message.answer(f"‚úÖ –î–æ–±–∞–≤–ª–µ–Ω–æ: <b>{text}</b>")

    kb = builders.InlineKeyboardBuilder()
    kb.button(text="üîô –ö —Å–ø–∏—Å–∫—É –∑–∞–¥–∞—á", callback_data=f"open_cat:{role}:{shift_type}")
    kb.button(text="üè† –ó–∞–∫–æ–Ω—á–∏—Ç—å —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ", callback_data="back_to_admin")
    kb.adjust(1)
    
    await message.answer("üëá –í–≤–µ–¥–∏—Ç–µ —Å–ª–µ–¥—É—é—â—É—é –∑–∞–¥–∞—á—É –ò–õ–ò –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã –∑–∞–∫–æ–Ω—á–∏—Ç—å:", reply_markup=kb.as_markup())

==================== FILE: ./app/handlers/super_admin/__init__.py ====================



==================== FILE: ./app/handlers/super_admin/menu.py ====================

from aiogram import Router, F, Bot
from aiogram.types import Message, CallbackQuery, ReplyKeyboardMarkup, KeyboardButton
from aiogram.filters import Command, StateFilter
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.fsm.context import FSMContext
from aiogram.exceptions import TelegramBadRequest
from app.core.config import SUPER_ADMIN_PASSWORD
from app.database.repo import saas as saas_repo
from app.keyboards import reply
from app.states.states import RootState

router = Router()

async def get_dashboard_data():
    stats = await saas_repo.get_platform_stats()
    text = (
        f"üåå <b>SaaS MASTER PANEL</b>\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"üè¢ <b>–ö–æ—Ñ–µ–π–Ω–∏:</b> {stats['cafes']}\n"
        f"üë• <b>–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</b> {stats['users']}\n"
        f"üü¢ <b>–ê–∫—Ç–∏–≤–Ω—ã–µ —Å–º–µ–Ω—ã:</b> {stats['shifts']}\n"
        f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n"
        f"<i>–í—ã–±–µ—Ä–∏—Ç–µ —Å–∏—Å—Ç–µ–º–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ:</i>"
    )
    builder = InlineKeyboardBuilder()
    builder.button(text="‚ú® –°–æ–∑–¥–∞—Ç—å Magic Link", callback_data="root_pre_gen")
    builder.button(text="üìã –°–ø–∏—Å–æ–∫ –ö–æ—Ñ–µ–µ–Ω", callback_data="root_list_cafes")
    builder.button(text="üì¢ –†–∞—Å—Å—ã–ª–∫–∞ –≤–ª–∞–¥–µ–ª—å—Ü–∞–º", callback_data="root_broadcast")
    builder.button(text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å", callback_data="root_refresh")
    builder.adjust(1)
    return text, builder.as_markup()

@router.callback_query(F.data.startswith("root_"), ~StateFilter(RootState))
async def security_check(callback: CallbackQuery):
    await callback.answer("üîí –°–µ—Å—Å–∏—è –∑–∞–∫—Ä—ã—Ç–∞. –í–æ–π–¥–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.", show_alert=True)
    try: await callback.message.edit_text("üîí <b>–°–µ—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞.</b>\n–ü–∞–Ω–µ–ª—å –æ—Ç–∫–ª—é—á–µ–Ω–∞.", reply_markup=None)
    except: pass

@router.message(Command("root_login"))
async def root_login_cmd(message: Message, state: FSMContext):
    parts = message.text.split()
    if len(parts) < 2 or parts[1] != SUPER_ADMIN_PASSWORD: return
    try: await message.delete()
    except: pass
    
    await state.set_state(RootState.active)
    
    await message.answer("üîë <b>Master-–¥–æ—Å—Ç—É–ø –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω.</b>", reply_markup=reply.super_admin_panel())
    
    text, kb = await get_dashboard_data()
    await message.answer(text, reply_markup=kb)

@router.message(F.text == "üëë –ü–∞–Ω–µ–ª—å –í–ª–∞–¥–µ–ª—å—Ü–∞")
async def root_panel_btn(message: Message, state: FSMContext):
    current_state = await state.get_state()
    if not current_state:
        return await message.answer("üîí –°–Ω–∞—á–∞–ª–∞ –≤–æ–π–¥–∏—Ç–µ —á–µ—Ä–µ–∑ /root_login")

    text, kb = await get_dashboard_data()
    await message.answer(text, reply_markup=kb)

@router.callback_query(F.data == "root_refresh")
async def root_refresh_handler(callback: CallbackQuery):
    text, kb = await get_dashboard_data()
    try:
        await callback.message.edit_text(text, reply_markup=kb)
    except TelegramBadRequest:
        pass 
    await callback.answer()

@router.callback_query(F.data == "root_pre_gen")
async def root_gen_ask_tag(callback: CallbackQuery, state: FSMContext):
    kb = ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚è© –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (–î–ª—è –ª—é–±–æ–≥–æ)")],
            [KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞")]
        ], 
        resize_keyboard=True
    )
    await state.set_state(RootState.waiting_target_id)
    try: await callback.message.delete()
    except: pass
    await callback.message.answer("üéØ <b>–î–ª—è –∫–æ–≥–æ –ª–∏—Ü–µ–Ω–∑–∏—è?</b>\n–í–≤–µ–¥–∏—Ç–µ @username –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å:", reply_markup=kb)
    await callback.answer()

@router.message(RootState.waiting_target_id)
async def root_gen_finish(message: Message, state: FSMContext, bot: Bot):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await state.set_state(RootState.active)
        await message.answer("–°–æ–∑–¥–∞–Ω–∏–µ –ª–∏—Ü–µ–Ω–∑–∏–∏ –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=reply.super_admin_panel())
        dash_text, dash_kb = await get_dashboard_data()
        return await message.answer(dash_text, reply_markup=dash_kb)

    tag = None if message.text == "‚è© –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å (–î–ª—è –ª—é–±–æ–≥–æ)" else message.text.lstrip("@").strip()
    key = await saas_repo.create_license_key(message.from_user.id, tag)
    info = await bot.get_me()
    
    await state.set_state(RootState.active)
    
    text = f"‚ú® <b>Magic Link –≥–æ—Ç–æ–≤–∞!</b>\n\nüîó <code>https://t.me/{info.username}?start={key}</code>\n\n"
    if tag: text += f"üîí <b>–î–ª—è:</b> @{tag}"
    else: text += "üîì <b>–î–ª—è –≤—Å–µ—Ö.</b>"
    
    await message.answer(text, reply_markup=reply.super_admin_panel())
    dash_text, dash_kb = await get_dashboard_data()
    await message.answer(dash_text, reply_markup=dash_kb)

@router.callback_query(F.data == "root_broadcast")
async def root_broadcast_start(callback: CallbackQuery, state: FSMContext):
    await state.set_state(RootState.waiting_broadcast_text)
    try: await callback.message.delete()
    except: pass
    await callback.message.answer("‚úçÔ∏è <b>–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç —Ä–∞—Å—Å—ã–ª–∫–∏:</b>", reply_markup=reply.cancel())
    await callback.answer()

@router.message(RootState.waiting_broadcast_text)
async def root_broadcast_finish(message: Message, state: FSMContext, bot: Bot):
    if message.text == "‚ùå –û—Ç–º–µ–Ω–∞":
        await state.set_state(RootState.active)
        await message.answer("–û—Ç–º–µ–Ω–∞.", reply_markup=reply.super_admin_panel())
        dash_text, dash_kb = await get_dashboard_data()
        return await message.answer(dash_text, reply_markup=dash_kb)

    owners = await saas_repo.get_all_owners_ids()
    count = 0
    for o_id in owners:
        try:
            await bot.send_message(o_id, f"üì¢ <b>–£–í–ï–î–û–ú–õ–ï–ù–ò–ï:</b>\n\n{message.text}")
            count += 1
        except: pass
        
    await state.set_state(RootState.active)
    await message.answer(f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {count}", reply_markup=reply.super_admin_panel())
    dash_text, dash_kb = await get_dashboard_data()
    await message.answer(dash_text, reply_markup=dash_kb)

@router.callback_query(F.data == "root_list_cafes")
async def list_cafes_handler(callback: CallbackQuery):
    cafes = await saas_repo.get_all_restaurants()
    if not cafes: 
        return await callback.answer("–ö–æ—Ñ–µ–µ–Ω –ø–æ–∫–∞ –Ω–µ—Ç.", show_alert=True)
    
    builder = InlineKeyboardBuilder()
    for c in cafes:
        icon = "üü¢" if c['is_active'] else "‚ùÑÔ∏è"
        builder.button(text=f"{icon} {c['title']}", callback_data=f"root_manage:{c['id']}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="root_refresh")
    builder.adjust(1)
    
    await callback.message.edit_text("üìã <b>–ö–æ—Ñ–µ–π–Ω–∏ –≤ —Å–∏—Å—Ç–µ–º–µ:</b>", reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("root_manage:"))
async def manage_cafe_view(callback: CallbackQuery):
    r_id = int(callback.data.split(":")[1])
    active = await saas_repo.is_restaurant_active(r_id)
    
    status_text = "–ê–ö–¢–ò–í–ù–ê üü¢" if active else "–ó–ê–ú–û–†–û–ñ–ï–ù–ê ‚ùÑÔ∏è"
    btn_text = "‚ùÑÔ∏è –ó–∞–º–æ—Ä–æ–∑–∏—Ç—å" if active else "üü¢ –†–∞–∑–º–æ—Ä–æ–∑–∏—Ç—å"
    
    builder = InlineKeyboardBuilder()
    builder.button(text=btn_text, callback_data=f"root_toggle:{r_id}")
    builder.button(text="üóë –£–¥–∞–ª–∏—Ç—å –Ω–∞–≤—Å–µ–≥–¥–∞", callback_data=f"root_del_ask:{r_id}")
    builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="root_list_cafes")
    builder.adjust(1)
    
    await callback.message.edit_text(f"üîß <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–æ—Ñ–µ–π–Ω–µ–π #{r_id}</b>\n–°—Ç–∞—Ç—É—Å: {status_text}", reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("root_toggle:"))
async def toggle_cafe_status(callback: CallbackQuery, bot: Bot):
    r_id = int(callback.data.split(":")[1])
    info = await saas_repo.get_restaurant_info(r_id)
    new_status = await saas_repo.toggle_restaurant_status(r_id)
    
    msg = "‚ùÑÔ∏è –î–æ—Å—Ç—É–ø –∫ –≤–∞—à–µ–π –∫–æ—Ñ–µ–π–Ω–µ –∑–∞–º–æ—Ä–æ–∂–µ–Ω." if new_status == 0 else "üü¢ –í–∞—à–∞ –∫–æ—Ñ–µ–π–Ω—è —Ä–∞–∑–º–æ—Ä–æ–∂–µ–Ω–∞. –ú–æ–∂–Ω–æ –≤—Ö–æ–¥–∏—Ç—å."
    try: await bot.send_message(info['owner_tg_id'], f"‚ö†Ô∏è <b>–û–ø–æ–≤–µ—â–µ–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã:</b>\n\n–ö–æ—Ñ–µ–π–Ω—è: {info['title']}\n{msg}")
    except: pass
    
    await callback.answer("–°—Ç–∞—Ç—É—Å –æ–±–Ω–æ–≤–ª–µ–Ω")
    await manage_cafe_view(callback)

@router.callback_query(F.data.startswith("root_del_ask:"))
async def delete_cafe_ask(callback: CallbackQuery):
    r_id = int(callback.data.split(":")[1])
    builder = InlineKeyboardBuilder()
    builder.button(text="‚ùå –ü–û–î–¢–í–ï–†–î–ò–¢–¨ –£–î–ê–õ–ï–ù–ò–ï", callback_data=f"root_del_conf:{r_id}")
    builder.button(text="üîô –û—Ç–º–µ–Ω–∞", callback_data=f"root_manage:{r_id}")
    builder.adjust(1)
    await callback.message.edit_text(f"‚ö†Ô∏è <b>–í—ã —É–≤–µ—Ä–µ–Ω—ã?</b>\n\n–£–¥–∞–ª–µ–Ω–∏–µ –∫–æ—Ñ–µ–π–Ω–∏ #{r_id} —É–Ω–∏—á—Ç–æ–∂–∏—Ç –≤—Å–µ –¥–∞–Ω–Ω—ã–µ (—Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤, —Å–º–µ–Ω—ã, –æ—Ç—á–µ—Ç—ã).", reply_markup=builder.as_markup())
    await callback.answer()

@router.callback_query(F.data.startswith("root_del_conf:"))
async def delete_cafe_confirm(callback: CallbackQuery, bot: Bot):
    r_id = int(callback.data.split(":")[1])
    info = await saas_repo.get_restaurant_info(r_id)
    users = await saas_repo.get_restaurant_users(r_id)
    
    for u_id in users:
        try: await bot.send_message(u_id, f"üö´ <b>–ö–æ—Ñ–µ–π–Ω—è '{info['title']}' –±—ã–ª–∞ —É–¥–∞–ª–µ–Ω–∞ –∏–∑ —Å–∏—Å—Ç–µ–º—ã.</b>\n–í—Å–µ —Å–µ—Å—Å–∏–∏ –∑–∞–≤–µ—Ä—à–µ–Ω—ã.")
        except: pass
        
    await saas_repo.delete_restaurant(r_id)
    await callback.answer("–ö–æ—Ñ–µ–π–Ω—è —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–∞", show_alert=True)
    await list_cafes_handler(callback)

@router.message(F.text == "üö™ –í—ã–π—Ç–∏ –∏–∑ —Å–∏—Å—Ç–µ–º—ã")
async def root_logout(message: Message, state: FSMContext):
    await state.clear()
    await message.answer("üîí –ú–∞—Å—Ç–µ—Ä-—Å–µ—Å—Å–∏—è –∑–∞–∫—Ä—ã—Ç–∞.", reply_markup=reply.guest())

==================== FILE: ./app/services/auth.py ====================

from app.database.repo import users as user_repo

async def try_login(tg_id: int, restaurant_id: int, input_pin: str):
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–∏–Ω-–∫–æ–¥ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞.
    """
    if not restaurant_id:
        return None
        
    user = await user_repo.get_user(tg_id, restaurant_id)
    
    if user and user["pin_hash"] == user_repo.hash_pin(input_pin):
        if not user['is_active']:
            return "disabled"
             
        await user_repo.create_session(tg_id, restaurant_id, user["role"])
        return user
        
    return None

async def logout(tg_id: int):
    await user_repo.delete_session(tg_id)

==================== FILE: ./app/services/tasks.py ====================

import aiosqlite
from datetime import datetime
from app.core.config import DB_PATH, TZ
from app.database.repo import tasks as task_repo

async def try_complete_task(task_id: int, restaurant_id: int):
    """
    –ü—ã—Ç–∞–µ—Ç—Å—è –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–¥–∞—á—É.
    """
    task = await task_repo.get_task_details(task_id, restaurant_id)
    if not task:
        return 0, ""

    if task['status'] != 'pending':
        return 0, ""

    if task['deadline']:
        try:
            deadline_dt = datetime.strptime(task['deadline'], "%Y-%m-%d %H:%M:%S")
            now_dt = datetime.now(TZ).replace(tzinfo=None)

            if now_dt > deadline_dt:
                async with aiosqlite.connect(DB_PATH) as db:
                    await db.execute(
                        "UPDATE extra_tasks SET status = 'expired' WHERE id = ? AND restaurant_id = ?", 
                        (task_id, restaurant_id)
                    )
                    await db.commit()
                return -1, ""
        except ValueError:
            pass 

    await task_repo.mark_task_completed(task_id, restaurant_id)
    await task_repo.add_bonus(task['assigned_to'], restaurant_id, task['reward'])

    return task['reward'], task['text']

==================== FILE: ./app/services/shift.py ====================

import json
import aiosqlite
from datetime import datetime
from app.database.repo import shifts as shift_repo, tasks as task_repo, roles as role_repo
from app.core.config import DB_PATH, TZ

def calculate_duration(start_str: str):
    start_dt = datetime.strptime(start_str, "%Y-%m-%d %H:%M:%S")
    end_dt = datetime.now(TZ).replace(tzinfo=None)
    duration = end_dt - start_dt
    hours = int(duration.total_seconds() // 3600)
    minutes = int((duration.total_seconds() % 3600) // 60)
    return hours, minutes

async def toggle_duty(tg_id: int, restaurant_id: int, task_index: int, is_checked: bool, master_tasks_list: list):
    active = await shift_repo.get_active_shift(tg_id, restaurant_id)
    if not active: return None

    try: 
        data = json.loads(active['report']) if active['report'] else {}
    except json.JSONDecodeError:
        data = {}

    user_duties = data.get('duties', [])

    if len(user_duties) != len(master_tasks_list):
        new_duties = []
        for i, title in enumerate(master_tasks_list):
            is_done = False
            if i < len(user_duties):
                if user_duties[i].get('title') == title:
                    is_done = user_duties[i].get('done', False)
            
            new_duties.append({"title": title, "done": is_done})
        user_duties = new_duties

    if 0 <= task_index < len(user_duties):
        user_duties[task_index]['done'] = is_checked
        user_duties[task_index]['title'] = master_tasks_list[task_index]

    data['duties'] = user_duties
    new_report = json.dumps(data)
    await shift_repo.update_shift_report(active['id'], restaurant_id, new_report)
    
    return [t['done'] for t in user_duties]

async def close_shift_logic(tg_id: int, restaurant_id: int, raw_data: str, user_name: str, tasks_list: list, comment: str = None):
    active_shift = await shift_repo.get_active_shift(tg_id, restaurant_id)
    if not active_shift: return None

    async with aiosqlite.connect(DB_PATH) as db:
        async with db.execute(
            "SELECT text FROM extra_tasks WHERE assigned_to = ? AND status = 'pending' AND restaurant_id = ?", 
            (tg_id, restaurant_id)
        ) as cur:
            pending_tasks = await cur.fetchall()
        
        await db.execute(
            "UPDATE extra_tasks SET status = 'canceled' WHERE assigned_to = ? AND status = 'pending' AND restaurant_id = ?", 
            (tg_id, restaurant_id)
        )
        await db.commit()

    await shift_repo.end_shift(active_shift['id'], restaurant_id, raw_data)
    
    try:
        data = json.loads(raw_data)
    except:
        data = {}

    roles_map = await role_repo.get_roles_map(restaurant_id)
    r_name = roles_map.get(active_shift['role'], active_shift['role'])

    hours, minutes = calculate_duration(active_shift['started_at'])
    
    user_duties = data.get('duties', [])
    
    if not user_duties:
        user_duties = [{"title": t, "done": False} for t in tasks_list]

    missed = []
    completed_count = 0
    
    for i, title in enumerate(tasks_list):
        is_done = False
        if i < len(user_duties):
            is_done = user_duties[i].get('done', False)
        
        if is_done:
            completed_count += 1
        else:
            missed.append(title)

    total = len(tasks_list)
    efficiency = int((completed_count / total) * 100) if total > 0 else 0
    
    if efficiency == 100: grade = "‚≠ê‚≠ê‚≠ê (–ò–¥–µ–∞–ª—å–Ω–æ)"
    elif efficiency >= 80: grade = "‚≠ê‚≠ê (–•–æ—Ä–æ—à–æ)"
    else: grade = "‚ö†Ô∏è (–í–Ω–∏–º–∞–Ω–∏–µ!)"

    user_report = (
        f"üèÅ <b>–°–ú–ï–ù–ê –ó–ê–ö–†–´–¢–ê #{active_shift['id']}</b>\n"
        f"‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
        f"üë§ <b>–°–æ—Ç—Ä—É–¥–Ω–∏–∫:</b> {user_name} ({r_name})\n"
        f"üïí <b>–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:</b> {hours}—á {minutes}–º–∏–Ω\n"
        f"üìà <b>–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:</b> {efficiency}% {grade}\n"
        f"‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
    )
    
    if missed:
        user_report += "<b>‚ùå –ù–ï –í–´–ü–û–õ–ù–ï–ù–û (–ß–µ–∫-–ª–∏—Å—Ç):</b>\n" + "\n".join(f"‚Äî {t}" for t in missed) + "\n\n"
    else:
        user_report += "‚úÖ <i>–ß–µ–∫-–ª–∏—Å—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω –ø–æ–ª–Ω–æ—Å—Ç—å—é!</i>\n\n"

    if pending_tasks:
        user_report += "<b>üö´ –ü–†–û–ü–£–©–ï–ù–ù–´–ï –î–û–ü. –ó–ê–î–ê–ù–ò–Ø:</b>\n" + "\n".join(f"‚Äî {t[0]}" for t in pending_tasks) + "\n\n"

    if comment:
        user_report += f"üí¨ <b>–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π:</b> {comment}\n"

    return {
        "user_report": user_report
    }

==================== FILE: ./app/services/kpi.py ====================

import json
from app.database.repo import shifts as shift_repo

async def calculate_kpi(tg_id: int, restaurant_id: int):
    shifts = await shift_repo.get_monthly_stats(tg_id, restaurant_id)
    
    shifts_x = len(shifts)
    total_completed_items = 0 
    total_possible_items = 0 
    
    for s in shifts:
        try:
            data = json.loads(s['report']) if s['report'] else {}
            duties = data.get('duties', [])
            
            if not duties: continue
            
            done_count = len([d for d in duties if d['done']])
            total_count = len(duties)
            
            total_completed_items += done_count
            total_possible_items += total_count
            
        except json.JSONDecodeError:
            continue

    tasks_y_avg = round(total_completed_items / shifts_x, 1) if shifts_x > 0 else 0
    activity_score = total_completed_items 
    
    efficiency_percent = 0
    if total_possible_items > 0:
        efficiency_percent = int((total_completed_items / total_possible_items) * 100)
        
    is_eligible = efficiency_percent >= 90
    
    return {
        "shifts_x": shifts_x,
        "tasks_y_avg": tasks_y_avg,
        "activity_score": activity_score,
        "efficiency_percent": efficiency_percent,
        "is_eligible": is_eligible
    }